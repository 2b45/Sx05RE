From 94e6c37ddcc8e0ca55e06683e4c8a03919ab010c Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 16:38:32 +0800
Subject: [PATCH] audio-revert-to-kszaq-nougat-status

---
 drivers/amlogic/amaudio2/amaudio2.c | 905 ++++++++++++------------------------
 drivers/amlogic/amaudio2/amaudio2.h |   5 -
 sound/soc/aml/m8/Kconfig            |   2 -
 sound/soc/aml/m8/Makefile           |   4 -
 sound/soc/aml/m8/aml_audio_hw.c     | 768 +++++++++++++++++-------------
 sound/soc/aml/m8/aml_audio_hw.h     |  22 +-
 sound/soc/aml/m8/aml_audio_hw_pcm.c | 276 ++++++-----
 sound/soc/aml/m8/aml_g9tv.c         | 742 +++++++++++++++++------------
 sound/soc/aml/m8/aml_g9tv.h         |   9 +-
 sound/soc/aml/m8/aml_i2s.c          | 183 ++------
 sound/soc/aml/m8/aml_i2s_dai.c      |  36 +-
 sound/soc/aml/m8/aml_m8.c           | 259 +----------
 sound/soc/aml/m8/aml_m8.h           |  30 --
 sound/soc/aml/m8/aml_spdif_codec.c  |   5 +-
 sound/soc/aml/m8/aml_spdif_dai.c    |  85 ++--
 15 files changed, 1442 insertions(+), 1889 deletions(-)

diff --git a/drivers/amlogic/amaudio2/amaudio2.c b/drivers/amlogic/amaudio2/amaudio2.c
index e16ca5e..950a664 100644
--- a/drivers/amlogic/amaudio2/amaudio2.c
+++ b/drivers/amlogic/amaudio2/amaudio2.c
@@ -37,16 +37,12 @@
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 #endif
+
 /* Amlogic headers */
 #include <linux/amlogic/major.h>
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
-
-/*#define AMAUDIO2_DEBUG*/
-/*#define AMAUDIO2_USE_IRQ*/
-
 #include "amaudio2.h"
 
 #define BASE_IRQ                        (32)
@@ -80,9 +76,6 @@ int amaudio2_enable = 0;
 int output_device = 0;
 int input_device = 1;
 
-static int external_mute_flag;
-static int external_mute_enable = 1;
-
 static int int_num = INT_NUM;
 static int i2s_num = I2S_BLOCK;
 static int int_block = INT_BLOCK;
@@ -168,49 +161,26 @@ static struct amaudio_port_t amaudio_ports[] = {
 	},
 };
 
-static inline int16_t clip16(int x)
+static inline short clip16(int x)
 {
 	if (x < -32768)
 		return -32768;
 	else if (x > 32767)
 		return 32767;
 
-	return (int16_t)x;
+	return (short)x;
 }
 
-static inline int32_t clip24(int x)
+static inline int clip24(int x)
 {
 	if (x < -8388608)
 		return -8388608;
 	else if (x > 8388607)
 		return 8388607;
 
-	return (int32_t)x;
-}
-
-static inline int32_t clip32(long x)
-{
-	if (x < -2147483648)
-		return -2147483648;
-	else if (x > 2147483647)
-		return 2147483647;
-
-	return (int32_t)x;
+	return x;
 }
 
-int External_Mute(int mute_flag)
-{
-	if (mute_flag == 1) {
-		external_mute_flag = 1;
-		pr_info("amaudio2_out external mute!\n");
-	} else {
-		external_mute_flag = 0;
-		pr_info("amaudio2_out external unmute!\n");
-	}
-	return 0;
-}
-EXPORT_SYMBOL(External_Mute);
-
 static int amaudio_open(struct inode *inode, struct file *file)
 {
 	struct amaudio_port_t *this = &amaudio_ports[iminor(inode)];
@@ -219,7 +189,7 @@ static int amaudio_open(struct inode *inode, struct file *file)
 	int res = 0;
 
 	if (iminor(inode) == 0) {
-		pr_debug("amaudio2_out open!\n");
+		pr_info("amaudio2_out open!\n");
 		if (!this->dev->dma_mask)
 			this->dev->dma_mask = &amaudio_pcm_dmamask;
 		if (!this->dev->coherent_dma_mask)
@@ -254,30 +224,16 @@ static int amaudio_open(struct inode *inode, struct file *file)
 		amaudio->hw.size = get_i2s_out_size();
 		amaudio->hw.rd = get_i2s_out_ptr();
 
-#ifdef AMAUDIO2_USE_IRQ
 		spin_lock_init(&amaudio->sw.lock);
 		spin_lock_init(&amaudio->hw.lock);
 
 		if (request_irq(IRQ_OUT, i2s_out_callback, IRQF_SHARED,
 				"i2s_out", amaudio)) {
 			res = -EINVAL;
-			pr_err("amaudio2 request irq error!\n");
 			goto error;
 		}
-#else
-		mutex_init(&amaudio->sw.lock);
-		mutex_init(&amaudio->hw.lock);
 
-		if (request_threaded_irq(IRQ_OUT, NULL, i2s_out_callback,
-				IRQF_SHARED | IRQF_ONESHOT,
-				"i2s_out", (void *)amaudio)) {
-			res = -EINVAL;
-			pr_err("amaudio2 request irq error!\n");
-			goto error;
-		}
-#endif
-
-		aml_aiu_update_bits(AIU_MEM_I2S_MASKS, 0xffff << 16,
+		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff << 16,
 				int_num << 16);
 
 		/*pr_info("channel: %d, int_num = %d,"
@@ -286,7 +242,7 @@ static int amaudio_open(struct inode *inode, struct file *file)
 		int_block, amaudio->hw.size);*/
 
 	} else if (iminor(inode) == 1) {
-		pr_debug("amaudio2_in opened\n");
+		pr_info("amaudio2_in opened\n");
 		if (!this->dev->dma_mask)
 			this->dev->dma_mask = &amaudio_pcm_dmamask;
 		if (!this->dev->coherent_dma_mask)
@@ -335,7 +291,7 @@ static int amaudio_mmap(struct file *file, struct vm_area_struct *vma)
 						  amaudio->sw.size);
 		return mmap_flag;
 	} else if (amaudio->type == 1) {
-		pr_debug("audio in mmap!\n");
+		pr_info("audio in mmap!\n");
 	} else {
 		return -ENODEV;
 	}
@@ -345,14 +301,14 @@ static int amaudio_mmap(struct file *file, struct vm_area_struct *vma)
 
 static unsigned get_i2s_out_size(void)
 {
-	return aml_aiu_read(AIU_MEM_I2S_END_PTR)
-	       - aml_aiu_read(AIU_MEM_I2S_START_PTR) + i2s_num;
+	return aml_read_cbus(AIU_MEM_I2S_END_PTR)
+	       - aml_read_cbus(AIU_MEM_I2S_START_PTR) + i2s_num;
 }
 
 static unsigned get_i2s_out_ptr(void)
 {
-	return aml_aiu_read(AIU_MEM_I2S_RD_PTR)
-	       - aml_aiu_read(AIU_MEM_I2S_START_PTR);
+	return aml_read_cbus(AIU_MEM_I2S_RD_PTR)
+	       - aml_read_cbus(AIU_MEM_I2S_START_PTR);
 }
 
 void cover_memcpy(struct BUF *des, int a, struct BUF *src, int b,
@@ -361,16 +317,16 @@ void cover_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 	int i;
 	int samp;
 
-	int16_t *des_left = (int16_t *)(des->addr + a);
-	int16_t *des_right = des_left + 16;
-	int16_t *src_buf = (int16_t *)(src->addr + b);
+	short *des_left = (short *)(des->addr + a);
+	short *des_right = des_left + 16;
+	short *src_buf = (short *)(src->addr + b);
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	for (i = 0; i < count; i += 4) {
+	for (i = 0; i < count; i += 2) {
 		samp = ((*src_buf++) * direct_left_gain) >> 8;
-		*des_left++ = (int16_t)samp;
+		*des_left++ = (short)samp;
 		samp = ((*src_buf++) * direct_right_gain) >> 8;
-		*des_right++ = (int16_t)samp;
+		*des_right++ = (short)samp;
 	}
 #else
 	int j;
@@ -378,9 +334,9 @@ void cover_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 	for (i = 0; i < count; i += 64) {
 		for (j = 0; j < 16; j++) {
 			samp = ((*src_buf++) * direct_left_gain) >> 8;
-			*des_left++ = (int16_t)samp;
+			*des_left++ = (short)samp;
 			samp = ((*src_buf++) * direct_right_gain) >> 8;
-			*des_right++ = (int16_t)samp;
+			*des_right++ = (short)samp;
 		}
 		des_left += 16;
 		des_right += 16;
@@ -394,12 +350,12 @@ void direct_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 	int i;
 	int samp;
 
-	int16_t *des_left = (int16_t *)(des->addr + a);
-	int16_t *des_right = des_left + 16;
-	int16_t *src_buf = (int16_t *)(src->addr + b);
+	short *des_left = (short *)(des->addr + a);
+	short *des_right = des_left + 16;
+	short *src_buf = (short *)(src->addr + b);
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	for (i = 0; i < count; i += 4) {
+	for (i = 0; i < count; i += 2) {
 		samp = ((*des_left) * music_gain +
 			(*src_buf++) * direct_left_gain) >> 8;
 		*des_left++ = clip16(samp);
@@ -431,15 +387,15 @@ void inter_mix_memcpy(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
 	int i;
-	int16_t sampL, sampR;
+	short sampL, sampR;
 	int samp, sampLR;
 
-	int16_t *des_left = (int16_t *)(des->addr + a);
-	int16_t *des_right = des_left + 16;
-	int16_t *src_buf = (int16_t *)(src->addr + b);
+	short *des_left = (short *)(des->addr + a);
+	short *des_right = des_left + 16;
+	short *src_buf = (short *)(src->addr + b);
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	for (i = 0; i < count; i += 4) {
+	for (i = 0; i < count; i += 2) {
 		sampL = *src_buf++;
 		sampR = *src_buf++;
 		/* Here has risk to distortion.
@@ -481,102 +437,70 @@ void cover_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
 	int i;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
+	int32_t *tfrom = (int32_t *)(src->addr + b);
+
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		for (i = 0; i < count; i += 8) {
-			*to++ = (int32_t)
-				(((long)(*tfrom++) * direct_left_gain) >> 8);
-			*to++ = (int32_t)
-				(((long)(*tfrom++) * direct_right_gain) >> 8);
-		}
-	} else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		for (i = 0; i < count; i += 4) {
-			*to++ = (int16_t)
-				(((*tfrom++) * direct_left_gain) >> 8);
-			*to++ = (int16_t)
-				(((*tfrom++) * direct_right_gain) >> 8);
-		}
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		*lf++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*cf++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*rf++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*ls++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*rs++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*lef++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+		*sbl++ = (int32_t)(((long)(*tfrom++) * direct_left_gain) >> 8);
+		*sbr++ = (int32_t)(((long)(*tfrom++) * direct_right_gain) >> 8);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
 	}
 #else
 	int j;
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 8;
-		rf = to + 2 * 8;
-		ls = to + 3 * 8;
-		rs = to + 4 * 8;
-		lef = to + 5 * 8;
-		sbl = to + 6 * 8;
-		sbr = to + 7 * 8;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 8; i++) {
-				*lf++ = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				*cf++ = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				*rf++ = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				*ls++ = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				*rs++ = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				*lef++ = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				*sbl++ = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				*sbr++ = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-			}
-			lf += 56;
-			cf += 56;
-			rf += 56;
-			ls += 56;
-			rs += 56;
-			lef += 56;
-			sbl += 56;
-			sbr += 56;
-		}
-	} else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		int16_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 16;
-		rf = to + 2 * 16;
-		ls = to + 3 * 16;
-		rs = to + 4 * 16;
-		lef = to + 5 * 16;
-		sbl = to + 6 * 16;
-		sbr = to + 7 * 16;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 16; i++) {
-				*lf++ = ((*tfrom++) * direct_left_gain) >> 8;
-				*cf++ = ((*tfrom++) * direct_right_gain) >> 8;
-				*rf++ = ((*tfrom++) * direct_left_gain) >> 8;
-				*ls++ = ((*tfrom++) * direct_right_gain) >> 8;
-				*rs++ = ((*tfrom++) * direct_left_gain) >> 8;
-				*lef++ = ((*tfrom++) * direct_right_gain) >> 8;
-				*sbl++ = ((*tfrom++) * direct_left_gain) >> 8;
-				*sbr++ = ((*tfrom++) * direct_right_gain) >> 8;
-			}
-			lf += 7 * 16;
-			cf += 7 * 16;
-			rf += 7 * 16;
-			ls += 7 * 16;
-			rs += 7 * 16;
-			lef += 7 * 16;
-			sbl += 7 * 16;
-			sbr += 7 * 16;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
+	for (j = 0; j < count; j += 256) {
+		for (i = 0; i < 8; i++) {
+			*lf++ = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			*cf++ = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
+			*rf++ = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			*ls++ = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
+			*rs++ = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			*lef++ = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
+			*sbl++ = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			*sbr++ = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
 		}
+		lf += 56;
+		cf += 56;
+		rf += 56;
+		ls += 56;
+		rs += 56;
+		lef += 56;
+		sbl += 56;
+		sbr += 56;
 	}
 #endif
 }
@@ -585,140 +509,103 @@ void direct_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
 	int i;
-	int samp;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
+	int32_t *tfrom = (int32_t *)(src->addr + b);
+	int32_t samp;
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		for (i = 0; i < count; i += 8) {
-			samp = *to;
-			*to++ = clip32(((long)(samp) * music_gain +
-				(long)(*tfrom++) * direct_left_gain) >> 8);
-			samp = *to;
-			*to++ = clip32(((long)(samp) * music_gain +
-				(long)(*tfrom++) * direct_right_gain) >> 8);
-		}
-	 } else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		for (i = 0; i < count; i += 4) {
-			samp = *to;
-			*to++ = clip16(((samp) * music_gain +
-				(*tfrom++) * direct_left_gain) >> 8);
-			samp = *to;
-			*to++ = clip16(((samp) * music_gain +
-				(*tfrom++) * direct_right_gain) >> 8);
-		}
-	 }
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		samp = *lf;
+		*lf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *cf;
+		*cf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *rf;
+		*rf++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *ls;
+		*ls++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *rs;
+		*rs++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *lef;
+		*lef++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+		samp = *sbl;
+		*sbl++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_left_gain)) >> 8);
+		samp = *sbr;
+		*sbr++ = (int32_t)((long)(((samp) * music_gain +
+			(*tfrom++) * direct_right_gain)) >> 8);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
+	}
 #else
 	int j;
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 8;
-		rf = to + 2 * 8;
-		ls = to + 3 * 8;
-		rs = to + 4 * 8;
-		lef = to + 5 * 8;
-		sbl = to + 6 * 8;
-		sbr = to + 7 * 8;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 8; i++) {
-				samp = *lf;
-				*lf++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_left_gain)
-					>> 8);
-				samp = *cf;
-				*cf++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_right_gain)
-					>> 8);
-				samp = *rf;
-				*rf++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_left_gain)
-					>> 8);
-				samp = *ls;
-				*ls++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_right_gain)
-					>> 8);
-				samp = *rs;
-				*rs++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_left_gain)
-					>> 8);
-				samp = *lef;
-				*lef++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_right_gain)
-					>> 8);
-				samp = *sbl;
-				*sbl++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_left_gain)
-					>> 8);
-				samp = *sbr;
-				*sbr++ = clip24(((samp) * music_gain +
-					((*tfrom++) >> 8) * direct_right_gain)
-					>> 8);
-			}
-			lf += 56;
-			cf += 56;
-			rf += 56;
-			ls += 56;
-			rs += 56;
-			lef += 56;
-			sbl += 56;
-			sbr += 56;
-		}
-	} else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		int16_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 16;
-		rf = to + 2 * 16;
-		ls = to + 3 * 16;
-		rs = to + 4 * 16;
-		lef = to + 5 * 16;
-		sbl = to + 6 * 16;
-		sbr = to + 7 * 16;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 16; i++) {
-				samp = *lf;
-				*lf++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_left_gain) >> 8);
-				samp = *cf;
-				*cf++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_right_gain) >> 8);
-				samp = *rf;
-				*rf++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_left_gain) >> 8);
-				samp = *ls;
-				*ls++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_right_gain) >> 8);
-				samp = *rs;
-				*rs++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_left_gain) >> 8);
-				samp = *lef;
-				*lef++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_right_gain) >> 8);
-				samp = *sbl;
-				*sbl++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_left_gain) >> 8);
-				samp = *sbr;
-				*sbr++ = clip16(((samp) * music_gain +
-					(*tfrom++) * direct_right_gain) >> 8);
-			}
-			lf += 7 * 16;
-			cf += 7 * 16;
-			rf += 7 * 16;
-			ls += 7 * 16;
-			rs += 7 * 16;
-			lef += 7 * 16;
-			sbl += 7 * 16;
-			sbr += 7 * 16;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
+	for (j = 0; j < count; j += 256) {
+		for (i = 0; i < 8; i++) {
+			samp = *lf;
+			*lf++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_left_gain) >> 8);
+			samp = *cf;
+			*cf++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_right_gain) >> 8);
+			samp = *rf;
+			*rf++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_left_gain) >> 8);
+			samp = *ls;
+			*ls++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_right_gain) >> 8);
+			samp = *rs;
+			*rs++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_left_gain) >> 8);
+			samp = *lef;
+			*lef++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_right_gain) >> 8);
+			samp = *sbl;
+			*sbl++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_left_gain) >> 8);
+			samp = *sbr;
+			*sbr++ = clip24(((samp) * music_gain +
+				((*tfrom++) >> 8) * direct_right_gain) >> 8);
 		}
+		lf += 56;
+		cf += 56;
+		rf += 56;
+		ls += 56;
+		rs += 56;
+		lef += 56;
+		sbl += 56;
+		sbr += 56;
 	}
 #endif
 }
@@ -727,181 +614,119 @@ void inter_mix_memcpy_8_channel(struct BUF *des, int a, struct BUF *src, int b,
 				unsigned count)
 {
 	int i;
-	int samp, sampLR, sampL, sampR;
+	int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
+	int32_t *to = (int32_t *)(des->addr + a);
+	int32_t *tfrom = (int32_t *)(src->addr + b);
+	int32_t samp, sampLR, sampL, sampR;
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		for (i = 0; i < count; i += 8) {
-			sampL = (int)
-				(((long)(*tfrom++) * direct_left_gain) >> 8);
-			sampR = (int)
-				(((long)(*tfrom++) * direct_right_gain) >> 8);
+	lf = to;
+	cf = to + 1;
+	rf = to + 2;
+	ls = to + 3;
+	rs = to + 4;
+	lef = to + 5;
+	sbl = to + 6;
+	sbr = to + 7;
+
+	for (i = 0; i < count; i += 32) {
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+
+		samp = *lf;
+		*lf++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *cf;
+		*cf++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *rf;
+		*rf++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *ls;
+		*ls++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *rs;
+		*rs++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *lef;
+		*lef++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		sampL = (int32_t)((long)((*tfrom++) * direct_left_gain) >> 8);
+		sampR = (int32_t)((long)((*tfrom++) * direct_right_gain) >> 8);
+		sampLR = (sampL + sampR) >> 1;
+		samp = *sbl;
+		*sbl++ = (int32_t)((long)samp * music_gain + sampLR);
+		samp = *sbr;
+		*sbr++ = (int32_t)((long)samp * music_gain + sampLR);
+
+		lf += 7;
+		cf += 7;
+		rf += 7;
+		ls += 7;
+		rs += 7;
+		lef += 7;
+		sbl += 7;
+		sbr += 7;
+	}
+#else
+	int j;
+
+	lf = to;
+	cf = to + 1 * 8;
+	rf = to + 2 * 8;
+	ls = to + 3 * 8;
+	rs = to + 4 * 8;
+	lef = to + 5 * 8;
+	sbl = to + 6 * 8;
+	sbr = to + 7 * 8;
+
+	for (j = 0; j < count; j += 256) {
+		for (i = 0; i < 8; i++) {
+			sampL = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			sampR = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
 			sampLR = (sampL + sampR) >> 1;
 
-			samp = *to;
-			*to++ = clip32(
-				(((long)samp * music_gain) >> 8) + sampLR);
-			samp = *to;
-			*to++ = clip32(
-				(((long)samp * music_gain) >> 8) + sampLR);
-		}
-	} else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		for (i = 0; i < count; i += 4) {
-			sampL = (int)(((*tfrom++) * direct_left_gain) >> 8);
-			sampR = (int)(((*tfrom++) * direct_right_gain) >> 8);
+			samp = *lf;
+			*lf++ = clip24(((samp) >> 8) * music_gain + sampLR);
+			samp = *cf;
+			*cf++ = clip24(((samp) >> 8) * music_gain + sampLR);
+
+			sampL = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			sampR = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
 			sampLR = (sampL + sampR) >> 1;
+			samp = *rf;
+			*rf++ = clip24(((samp) >> 8) * music_gain + sampLR);
+			samp = *ls;
+			*ls++ = clip24(((samp) >> 8) * music_gain + sampLR);
 
-			samp = *to;
-			*to++ = clip16(
-				(((long)samp * music_gain) >> 8) + sampLR);
-			samp = *to;
-			*to++ = clip16(
-				(((long)samp * music_gain) >> 8) + sampLR);
-		}
-	}
-#else
-	int j;
-	if (aml_i2s_playback_format == 32 || aml_i2s_playback_format == 24) {
-		int32_t *to = (int32_t *)(des->addr + a);
-		int32_t *tfrom = (int32_t *)(src->addr + b);
-		int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 8;
-		rf = to + 2 * 8;
-		ls = to + 3 * 8;
-		rs = to + 4 * 8;
-		lef = to + 5 * 8;
-		sbl = to + 6 * 8;
-		sbr = to + 7 * 8;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 8; i++) {
-				sampL = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				sampR = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				sampLR = (sampL + sampR) >> 1;
-
-				samp = *lf;
-				*lf++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *cf;
-				*cf++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				sampR = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *rf;
-				*rf++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *ls;
-				*ls++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				sampR = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *rs;
-				*rs++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *lef;
-				*lef++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = (((*tfrom++) >> 8) * direct_left_gain)
-					>> 8;
-				sampR = (((*tfrom++) >> 8) * direct_right_gain)
-					>> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *sbl;
-				*sbl++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *sbr;
-				*sbr++ = clip24(
-					((samp * music_gain) >> 8) + sampLR);
-			}
-			lf += 56;
-			cf += 56;
-			rf += 56;
-			ls += 56;
-			rs += 56;
-			lef += 56;
-			sbl += 56;
-			sbr += 56;
-		}
-	} else {
-		int16_t *to = (int16_t *)(des->addr + a);
-		int16_t *tfrom = (int16_t *)(src->addr + b);
-		int16_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
-
-		lf = to;
-		cf = to + 1 * 16;
-		rf = to + 2 * 16;
-		ls = to + 3 * 16;
-		rs = to + 4 * 16;
-		lef = to + 5 * 16;
-		sbl = to + 6 * 16;
-		sbr = to + 7 * 16;
-		for (j = 0; j < count; j += 256) {
-			for (i = 0; i < 16; i++) {
-				sampL = ((*tfrom++) * direct_left_gain) >> 8;
-				sampR = ((*tfrom++) * direct_right_gain) >> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *lf;
-				*lf++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *cf;
-				*cf++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = ((*tfrom++) * direct_left_gain) >> 8;
-				sampR = ((*tfrom++) * direct_right_gain) >> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *rf;
-				*rf++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *ls;
-				*ls++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = ((*tfrom++) * direct_left_gain) >> 8;
-				sampR = ((*tfrom++) * direct_right_gain) >> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *rs;
-				*rs++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *lef;
-				*lef++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-
-				sampL = ((*tfrom++) * direct_left_gain) >> 8;
-				sampR = ((*tfrom++) * direct_right_gain) >> 8;
-				sampLR = (sampL + sampR) >> 1;
-				samp = *sbl;
-				*sbl++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-				samp = *sbr;
-				*sbr++ = clip16(
-					((samp * music_gain) >> 8) + sampLR);
-			}
-			lf += 7 * 16;
-			cf += 7 * 16;
-			rf += 7 * 16;
-			ls += 7 * 16;
-			rs += 7 * 16;
-			lef += 7 * 16;
-			sbl += 7 * 16;
-			sbr += 7 * 16;
+			sampL = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			sampR = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
+			sampLR = (sampL + sampR) >> 1;
+			samp = *rs;
+			*rs++ = clip24(((samp) >> 8) * music_gain + sampLR);
+			samp = *lef;
+			*lef++ = clip24(((samp) >> 8) * music_gain + sampLR);
+
+			sampL = (((*tfrom++) >> 8) * direct_left_gain) >> 8;
+			sampR = (((*tfrom++) >> 8) * direct_right_gain) >> 8;
+			sampLR = (sampL + sampR) >> 1;
+			samp = *sbl;
+			*sbl++ = clip24(((samp) >> 8) * music_gain + sampLR);
+			samp = *sbr;
+			*sbr++ = clip24(((samp) >> 8) * music_gain + sampLR);
 		}
+		lf += 56;
+		cf += 56;
+		rf += 56;
+		ls += 56;
+		rs += 56;
+		lef += 56;
+		sbl += 56;
+		sbr += 56;
 	}
 #endif
 }
@@ -910,17 +735,13 @@ static void i2s_copy(struct amaudio_t *amaudio)
 {
 	struct BUF *hw = &amaudio->hw;
 	struct BUF *sw = &amaudio->sw;
+	unsigned long swirqflags, hwirqflags;
 	unsigned i2s_out_ptr = get_i2s_out_ptr();
 	unsigned alsa_delay =
 		(aml_i2s_alsa_write_addr + hw->size - i2s_out_ptr) % hw->size;
 	unsigned amaudio_delay = (hw->wr + hw->size - i2s_out_ptr) % hw->size;
 
-#ifdef AMAUDIO2_USE_IRQ
-	unsigned long swirqflags, hwirqflags;
 	spin_lock_irqsave(&hw->lock, hwirqflags);
-#else
-	mutex_lock(&hw->lock);
-#endif
 
 	hw->rd = i2s_out_ptr;
 	hw->level = amaudio_delay;
@@ -935,7 +756,7 @@ static void i2s_copy(struct amaudio_t *amaudio)
 	}
 
 	if (sw->level > soft_buffer_threshold) {
-		/*pr_debug(
+		/*pr_info(
 		"Reset sw: hw->wr = %x,hw->rd = %x, hw->level = %x,"
 		"alsa_delay:%x,sw->wr = %x, sw->rd = %x,sw->level = %x\n",
 		hw->wr, hw->rd, hw->level, alsa_delay,
@@ -953,91 +774,30 @@ static void i2s_copy(struct amaudio_t *amaudio)
 				(sw->rd + int_block > sw->size));
 	BUG_ON((hw->wr < 0) || (sw->rd < 0));
 
-	if (external_mute_enable == 1 && external_mute_flag == 1) {
-		memset((hw->addr + hw->wr), 0, int_block);
-	} else {
-		if (audio_out_mode == 0)
-			(*aml_cover_memcpy)
-					(hw, hw->wr, sw, sw->rd, int_block);
-		else if (audio_out_mode == 1)
-			(*aml_inter_mix_memcpy)
-					(hw, hw->wr, sw, sw->rd, int_block);
-		else if (audio_out_mode == 2)
-			(*aml_direct_mix_memcpy)
-					(hw, hw->wr, sw, sw->rd, int_block);
-	}
+	if (audio_out_mode == 0)
+		(*aml_cover_memcpy)(hw, hw->wr, sw, sw->rd, int_block);
+	else if (audio_out_mode == 1)
+		(*aml_inter_mix_memcpy)(hw, hw->wr, sw, sw->rd, int_block);
+	else if (audio_out_mode == 2)
+		(*aml_direct_mix_memcpy)(hw, hw->wr, sw, sw->rd, int_block);
 
 	hw->wr = (hw->wr + int_block) % hw->size;
 	hw->level = (hw->wr + hw->size - i2s_out_ptr) % hw->size;
 
-#ifdef AMAUDIO2_USE_IRQ
-	spin_unlock_irqrestore(&hw->lock, hwirqflags);
 	spin_lock_irqsave(&sw->lock, swirqflags);
-#else
-	mutex_unlock(&hw->lock);
-	mutex_lock(&sw->lock);
-#endif
-
 	sw->rd = (sw->rd + int_block) % sw->size;
 	sw->level = (sw->size + sw->wr - sw->rd) % sw->size;
-
-#ifdef AMAUDIO2_USE_IRQ
 	spin_unlock_irqrestore(&sw->lock, swirqflags);
-#else
-	mutex_unlock(&sw->lock);
-#endif
-	return;
 
-EXIT:
-
-#ifdef AMAUDIO2_USE_IRQ
-	spin_unlock_irqrestore(&hw->lock, hwirqflags);
-#else
-	mutex_unlock(&hw->lock);
-#endif
+EXIT:  spin_unlock_irqrestore(&hw->lock, hwirqflags);
 	return;
 }
 
-#ifdef AMAUDIO2_DEBUG
-#define period_reset	(1000*1000)
-#define CCCNT_WARN		2000
-static unsigned long start_time;
-static unsigned long isr_time;
-static unsigned long total_time;
-static unsigned long total_cnt;
-#endif
-
 static irqreturn_t i2s_out_callback(int irq, void *data)
 {
 	struct amaudio_t *amaudio = (struct amaudio_t *)data;
 
-#ifdef AMAUDIO2_DEBUG
-	unsigned long clk1, clk2;
-	unsigned int ratio = 0;
-	clk1 = sched_clock()/1000;
-#endif
-
 	i2s_copy(amaudio);
-
-#ifdef AMAUDIO2_DEBUG
-	clk2 = sched_clock()/1000;
-	isr_time += (clk2-clk1);
-	total_time = (clk2-start_time);
-	total_cnt++;
-
-	if (total_time >= period_reset) {
-		ratio = isr_time * 100 / total_time;
-		if ((ratio >= 20) || (total_cnt > CCCNT_WARN)) {
-			pr_err("Warning:isrtime:%ld totalTime:%ld ratio:%d, cnt:%d\n",
-				isr_time, total_time, ratio, (int)total_cnt);
-		}
-		start_time	= sched_clock()/1000;
-		isr_time	= 0;
-		total_time = 0;
-		total_cnt = 0;
-	}
-#endif
-
 	return IRQ_HANDLED;
 }
 
@@ -1061,9 +821,7 @@ static long amaudio_ioctl(struct file *file, unsigned int cmd,
 {
 	struct amaudio_t *amaudio = (struct amaudio_t *)file->private_data;
 	s32 r = 0;
-#ifdef AMAUDIO2_USE_IRQ
 	unsigned long swirqflags, hwirqflags;
-#endif
 
 	switch (cmd) {
 	case AMAUDIO_IOC_GET_SIZE:
@@ -1072,43 +830,22 @@ static long amaudio_ioctl(struct file *file, unsigned int cmd,
 		break;
 	case AMAUDIO_IOC_GET_PTR:
 		/* the read pointer of internal buffer */
-#ifdef AMAUDIO2_USE_IRQ
 		spin_lock_irqsave(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_lock(&amaudio->sw.lock);
-#endif
-
 		r = amaudio->sw.rd;
-
-#ifdef AMAUDIO2_USE_IRQ
 		spin_unlock_irqrestore(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_unlock(&amaudio->sw.lock);
-#endif
 		break;
 	case AMAUDIO_IOC_UPDATE_APP_PTR:
 		/*
 		 * the user space write pointer
 		 * of the internal buffer
 		 */
-#ifdef AMAUDIO2_USE_IRQ
 		spin_lock_irqsave(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_lock(&amaudio->sw.lock);
-#endif
-
 		amaudio->sw.wr = arg;
 		amaudio->sw.level = (amaudio->sw.size + amaudio->sw.wr
 					 - amaudio->sw.rd) % amaudio->sw.size;
-
-#ifdef AMAUDIO2_USE_IRQ
 		spin_unlock_irqrestore(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_unlock(&amaudio->sw.lock);
-#endif
-
 		if (amaudio->sw.wr % i2s_num)
-			pr_err("wr:%x, not %d Bytes align\n",
+			pr_info("wr:%x, not %d Bytes align\n",
 						amaudio->sw.wr, i2s_num);
 		break;
 	case AMAUDIO_IOC_RESET:
@@ -1117,36 +854,19 @@ static long amaudio_ioctl(struct file *file, unsigned int cmd,
 		 * pointer to get a given latency
 		 * this api should be called before fill datas
 		 */
-#ifdef AMAUDIO2_USE_IRQ
 		spin_lock_irqsave(&amaudio->hw.lock, hwirqflags);
-#else
-		mutex_lock(&amaudio->hw.lock);
-#endif
-
 		amaudio->hw.rd = get_i2s_out_ptr();
 		amaudio->hw.wr = (amaudio->hw.rd + latency) % amaudio->hw.size;
 		amaudio->hw.wr /= int_block;
 		amaudio->hw.wr *= int_block;
 		amaudio->hw.level = latency;
-
-#ifdef AMAUDIO2_USE_IRQ
 		spin_unlock_irqrestore(&amaudio->hw.lock, hwirqflags);
 		/* empty the buffer */
 		spin_lock_irqsave(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_unlock(&amaudio->hw.lock);
-		mutex_lock(&amaudio->sw.lock);
-#endif
-
 		amaudio->sw.wr = 0;
 		amaudio->sw.rd = 0;
 		amaudio->sw.level = 0;
-
-#ifdef AMAUDIO2_USE_IRQ
 		spin_unlock_irqrestore(&amaudio->sw.lock, swirqflags);
-#else
-		mutex_unlock(&amaudio->sw.lock);
-#endif
 		/*pr_info("Reset amaudio2: latency=%d bytes\n", latency);*/
 		break;
 	case AMAUDIO_IOC_AUDIO_OUT_MODE:
@@ -1238,7 +958,7 @@ static ssize_t store_direct_left_gain(struct class *class,
 		val = 256;
 
 	direct_left_gain = val;
-	pr_debug("direct_left_gain set to %d\n", direct_left_gain);
+	pr_info("direct_left_gain set to %d\n", direct_left_gain);
 	return count;
 }
 
@@ -1263,7 +983,7 @@ static ssize_t store_direct_right_gain(struct class *class,
 		val = 256;
 
 	direct_right_gain = val;
-	pr_debug("direct_right_gain set to %d\n", direct_right_gain);
+	pr_info("direct_right_gain set to %d\n", direct_right_gain);
 	return count;
 }
 
@@ -1288,7 +1008,7 @@ static ssize_t store_music_gain(struct class *class,
 		val = 256;
 
 	music_gain = val;
-	pr_debug("music_gain set to %d\n", music_gain);
+	pr_info("music_gain set to %d\n", music_gain);
 	return count;
 }
 
@@ -1366,27 +1086,6 @@ static ssize_t store_aml_output_driver(struct class *class,
 	return count;
 }
 
-static ssize_t show_aml_external_mute_enable(struct class *class,
-				struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", external_mute_enable);
-}
-
-static ssize_t store__aml_external_mute_enable(struct class *class,
-				struct class_attribute *attr,
-				const char *buf, size_t count)
-{
-	if (buf[0] == '0') {
-		pr_info("amaudio2_out external mute enable!\n");
-		external_mute_enable = 0;
-	} else if (buf[0] == '1') {
-		pr_info("amaudio2_out external mute disable!\n");
-		external_mute_enable = 1;
-	}
-
-	return count;
-}
-
 static struct class_attribute amaudio_attrs[] = {
 	__ATTR(aml_audio_out_mode,
 	       S_IRUGO | S_IWUSR,
@@ -1416,10 +1115,6 @@ static struct class_attribute amaudio_attrs[] = {
 	       S_IRUGO | S_IWUSR | S_IWGRP,
 	       show_aml_output_driver,
 	       store_aml_output_driver),
-	__ATTR(aml_external_mute_enable,
-	       S_IRUGO | S_IWUSR | S_IWGRP,
-	       show_aml_external_mute_enable,
-	       store__aml_external_mute_enable),
 	__ATTR_NULL
 };
 
diff --git a/drivers/amlogic/amaudio2/amaudio2.h b/drivers/amlogic/amaudio2/amaudio2.h
index c3a856b..d3f0708 100644
--- a/drivers/amlogic/amaudio2/amaudio2.h
+++ b/drivers/amlogic/amaudio2/amaudio2.h
@@ -36,11 +36,7 @@ struct BUF {
 	unsigned wr;
 	unsigned rd;
 	unsigned level;
-#ifdef AMAUDIO2_USE_IRQ
 	spinlock_t lock;
-#else
-	struct mutex lock;
-#endif
 };
 
 struct amaudio_t {
@@ -90,7 +86,6 @@ extern unsigned long aml_i2s_playback_start_addr;
 extern unsigned long aml_i2s_playback_phy_start_addr;
 extern unsigned long aml_i2s_alsa_write_addr;
 extern unsigned int aml_i2s_playback_channel;
-extern unsigned int aml_i2s_playback_format;
 
 #define AMAUDIO_IOC_MAGIC  'A'
 
diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index c718761..6d67a81 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -10,8 +10,6 @@ menuconfig SND_AML_M8
 	select SND_SOC_TAS5731
 	select SND_SOC_AMLT9015
 	select SND_SOC_AMLT9015S
-	select SND_SOC_AMLTXLX_ACODEC
-	select SND_SOC_TLV320AIC32X4
 	select SND_SOC_ES8323
 
 if SND_AML_M8
diff --git a/sound/soc/aml/m8/Makefile b/sound/soc/aml/m8/Makefile
index c9361f2..880617a 100644
--- a/sound/soc/aml/m8/Makefile
+++ b/sound/soc/aml/m8/Makefile
@@ -22,10 +22,6 @@ obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-dmic.o
 snd-soc-aml-spdif-codec-objs := aml_spdif_codec.o
 obj-$(CONFIG_SND_AML_M8_SOC) += snd-soc-aml-spdif-codec.o
 
-# AML SND IOMAP Support
-snd-soc-aml-snd-iomap-objs := aml_snd_iomap.o
-obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-snd-iomap.o
-
 #AML M8 Machine support
 snd-soc-aml-m8-objs := aml_m8.o
 obj-$(CONFIG_SND_AML_M8) += snd-soc-aml-m8.o
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 5e22883..fc91f09 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -27,15 +27,20 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 #include <linux/amlogic/cpu_version.h>
 #include "aml_audio_hw.h"
 
 /* i2s mode 0: master 1: slave */
 /* source: 0: linein; 1: ATV; 2: HDMI-in */
+unsigned ENABLE_IEC958 = 1;
 unsigned IEC958_MODE = AIU_958_MODE_PCM16;
 unsigned I2S_MODE = AIU_I2S_MODE_PCM16;
 unsigned audio_in_source = 0;
+void set_i2s_source(unsigned source)
+{
+	audio_in_source = source;
+	return;
+}
 
 int audio_in_buf_ready = 0;
 int audio_out_buf_ready = 0;
@@ -85,55 +90,105 @@ unsigned audioin_mode = I2SIN_MASTER_MODE;
 /* 1 => 'h800000 */
 unsigned int dac_mute_const = 0x800000;
 
+/*
+				fIn * (M)
+	    Fout   =  -----------------------------
+			    (N) * (OD+1) * (XD)
+*/
+int audio_clock_config_table[][13][2] = {
+	{
+	 /* 256 */
+#if OVERCLOCK == 0
+	 {0x0005cc08, (60 - 1)},	/* 32 */
+	 {0x0005e965, (40 - 1)},	/* 44.1 */
+	 {0x0007c4e6, (23 - 1)},	/* 48K */
+	 {0x0005cc08, (20 - 1)},	/* 96k ,24.576M */
+	 {0x0005cc08, (10 - 1)},	/* 192k, 49.152M */
+	 {0x0007f400, (125 - 1)},	/* 8k */
+	 {0x0006c6f6, (116 - 1)},	/* 11.025 */
+	 {0x0007e47f, (86 - 1)},	/* 12 */
+	 {0x0004f880, (100 - 1)},	/* 16 */
+	 {0x0004c4a4, (87 - 1)},	/* 22.05 */
+	 {0x0007e47f, (43 - 1)},	/* 24 */
+	 {0x0007f3f0, (127 - 1)},	/* 7875 */
+	 {0x0005c88b, (22 - 1)},	/* 88.2k ,22.579M */
+#else
+	 /* 512FS */
+	 {0x0004f880, (25 - 1)},	/* 32 */
+	 {0x0004cdf3, (21 - 1)},	/* 44.1 */
+	 {0x0006d0a4, (13 - 1)},	/* 48 */
+	 {0x0004e15a, (9 - 1)},
+	 {0x0006f207, (3 - 1)},
+	 {0x0004f880, (100 - 1)},	/* 8k */
+	 {0x0004c4a4, (87 - 1)},	/* 11.025 */
+	 {0x0007e47f, (43 - 1)},	/* 12 */
+	 {0x0004f880, (50 - 1)},	/* 16 */
+	 {0x0004cdf3, (42 - 1)},	/* 22.05 */
+	 {0x0007c4e6, (23 - 1)},	/* 24 */
+	 {0x0006e1b6, (76 - 1)},	/* 7875 */
+#endif
+	 },
+	{
+	 /* 384 */
+	 {0x0007c4e6, (23 - 1)},	/* 32 */
+	 {0x0004c4a4, (29 - 1)},	/* 44.1 */
+	 {0x0004cb18, (26 - 1)},	/* 48 */
+	 {0x0004cb18, (13 - 1)},	/* 96 */
+	 {0x0004e15a, (6 - 1)},
+	 {0x0007e47f, (86 - 1)},	/* 8k */
+	 {0x0007efa5, (61 - 1)},	/* 11.025 */
+	 {0x0006de98, (67 - 1)},	/* 12 */
+	 {0x0007e47f, (43 - 1)},	/* 16 */
+	 {0x0004c4a4, (58 - 1)},	/* 22.05 */
+	 {0x0004c60e, (53 - 1)},	/* 24 */
+	 {0x0007fdfa, (83 - 1)},	/* 7875 */
+	 }
+};
+
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	aml_aiu_write(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
-	aml_aiu_write(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
 #else
-	aml_aiu_write(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
-	aml_aiu_write(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
 #endif
 
 	if (channel == 8) {
 		/*select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_mster_clk*/
-		aml_aiu_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
+		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
 		/*unmute all channels*/
-		aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0 << 8);
+		aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0 << 8);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_MEM_I2S_END_PTR,
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
 #else
-		aml_aiu_write(AIU_MEM_I2S_END_PTR,
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
 #endif
 	} else {
 		/*select cts_clk_i958 as AIU clk to hdmi_tx_audio_mster_clk*/
-		aml_aiu_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
+		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
 		/*unmute 0/1 channel*/
-		aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xfc << 8);
+		aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xfc << 8);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_MEM_I2S_END_PTR,
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
 #else
-		aml_aiu_write(AIU_MEM_I2S_END_PTR,
+		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			(addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
 #endif
 	}
 	/* Hold I2S */
-	aml_aiu_update_bits(AIU_I2S_MISC, 0x1 << 2,
-				1 << 2);
-	/* force audio data to left or right */
-	aml_aiu_update_bits(AIU_I2S_MISC, 0x1 << 4,
-				1 << 4);
-	/* Release hold */
-	aml_aiu_update_bits(AIU_I2S_MISC, 0x1 << 2,
-				0 << 2);
+	aml_write_cbus(AIU_I2S_MISC, 0x0004);
+	/* Release hold and force audio data to left or right */
+	aml_write_cbus(AIU_I2S_MISC, 0x0010);
 
 	if (channel == 8) {
 		pr_info("%s channel == 8\n", __func__);
 		/* [31:16] IRQ block. */
-		aml_aiu_write(AIU_MEM_I2S_MASKS, (24 << 16) |
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
 		/* [15: 8] chan_mem_mask.
 		*  Each bit indicates which channels exist in memory
 		*/
@@ -145,74 +200,81 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 	} else {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 		/* [31:16] IRQ block. */
-		aml_aiu_write(AIU_MEM_I2S_MASKS, (24 << 16) |
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
 					(0xff << 8) |
 					(0xff << 0));
 #else
 		/* [31:16] IRQ block. */
-		aml_aiu_write(AIU_MEM_I2S_MASKS, (24 << 16) |
+		aml_write_cbus(AIU_MEM_I2S_MASKS, (24 << 16) |
 				   (0x3 << 8) |
 				   (0x3 << 0));
 #endif
 	}
 	/* 16 bit PCM mode */
-	/* aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
+	/* aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 6, 1); */
 	/* Set init high then low to initilize the I2S memory logic */
-	aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1, 1);
-	aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1, 0);
+	aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 1);
+	aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 0);
 
-	aml_aiu_write(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
-	aml_aiu_write(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
+	aml_write_cbus(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
+	aml_write_cbus(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
 
 	audio_out_buf_ready = 1;
 }
 
 void audio_set_958outbuf(u32 addr, u32 size, int flag)
 {
-	aml_aiu_write(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
-	aml_aiu_write(AIU_MEM_IEC958_RD_PTR,
-			       addr & 0xffffffc0);
-	if (flag == 0) {
-		/* this is for 16bit 2 channel */
+	if (ENABLE_IEC958) {
+		aml_write_cbus(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+		if (aml_read_cbus(AIU_MEM_IEC958_START_PTR) ==
+		    aml_read_cbus(AIU_MEM_I2S_START_PTR)) {
+			aml_write_cbus(AIU_MEM_IEC958_RD_PTR,
+				       aml_read_cbus(AIU_MEM_I2S_RD_PTR));
+		} else
+			aml_write_cbus(AIU_MEM_IEC958_RD_PTR,
+				       addr & 0xffffffc0);
+		if (flag == 0) {
+			/* this is for 16bit 2 channel */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_MEM_IEC958_END_PTR,
-			       (addr & 0xffffffc0) +
-			       (size & 0xffffffc0) - 8);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				(addr & 0xffffffc0) +
+				(size & 0xffffffc0) - 8);
 #else
-		aml_aiu_write(AIU_MEM_IEC958_END_PTR,
-			       (addr & 0xffffffc0) +
-			       (size & 0xffffffc0) - 64);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 64);
 #endif
-	} else {
-		/* this is for RAW mode */
+		} else {
+			/* this is for RAW mode */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_MEM_IEC958_END_PTR,
-					(addr & 0xffffffc0) +
-					(size & 0xffffffc0) - 8);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+						(addr & 0xffffffc0) +
+						(size & 0xffffffc0) - 8);
 #else
-		aml_aiu_write(AIU_MEM_IEC958_END_PTR,
-			       (addr & 0xffffffc0) +
-			       (size & 0xffffffc0) - 1);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
+				       (addr & 0xffffffc0) +
+				       (size & 0xffffffc0) - 1);
 #endif
-	}
+		}
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	aml_aiu_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0xffff);
 #else
-	aml_aiu_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
+		aml_cbus_update_bits(AIU_MEM_IEC958_MASKS, 0xffff, 0x303);
 #endif
-	aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
-	aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
 
-	aml_aiu_write(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
-	aml_aiu_write(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
+		aml_write_cbus(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
+		aml_write_cbus(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
+	}
 }
 
 /*
 i2s mode 0: master 1: slave
 din_sel 0:spdif 1:i2s 2:pcm 3: dmic
 */
-static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode,
-		u32 i2s_sync, u32 din_sel, u32 ch)
+static void i2sin_fifo0_set_buf(u32 addr, u32 size,
+				u32 i2s_mode, u32 i2s_sync, u32 din_sel)
 {
 	unsigned char mode = 0;
 	unsigned int sync_mode = 0, din_pos = 0;
@@ -222,26 +284,35 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode,
 		mode = 1;
 	if (din_sel != 1)
 		din_pos = 1;
-	aml_audin_write(AUDIN_FIFO0_START, addr & 0xffffffc0);
-	aml_audin_write(AUDIN_FIFO0_PTR, (addr & 0xffffffc0));
-	aml_audin_write(AUDIN_FIFO0_END,
-			   (addr & 0xffffffc0) + (size & 0xffffffc0) - 8);
-
-	aml_audin_write(AUDIN_FIFO0_CTRL, (1 << AUDIN_FIFO0_EN)	/* FIFO0_EN */
-			   | (1 << AUDIN_FIFO0_LOAD) /* load start address */
-			   | (din_sel << AUDIN_FIFO0_DIN_SEL) /*DIN from i2sin*/
-			   | (4 << AUDIN_FIFO0_ENDIAN) /*AUDIN_FIFO0_ENDIAN*/
-			   | ((ch == 2?2:1) << AUDIN_FIFO0_CHAN) /*ch mode ctl*/
-			   | (1 << AUDIN_FIFO0_UG) /* Urgent request. */
-	);
-
-	aml_audin_write(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
-			   | 2 << 2	/* 0: 8bit; 1:16bit; 2:32bit */
-			   | din_pos << 0);	/* fifo0_din_pos */
+	aml_write_cbus(AUDIN_FIFO0_START, addr & 0xffffffc0);
+	aml_write_cbus(AUDIN_FIFO0_PTR, (addr & 0xffffffc0));
+	aml_write_cbus(AUDIN_FIFO0_END,
+		       (addr & 0xffffffc0) + (size & 0xffffffc0) - 8);
+
+	aml_write_cbus(AUDIN_FIFO0_CTRL, (1 << AUDIN_FIFO0_EN)	/* FIFO0_EN */
+		       |(1 << AUDIN_FIFO0_LOAD)	/* load start address */
+		       |(din_sel << AUDIN_FIFO0_DIN_SEL)
+
+		       /* DIN from i2sin */
+		       /* |(1<<6)    // 32 bits data in. */
+		       /* |(0<<7)    // put the 24bits data to  low 24 bits */
+		       | (4 << AUDIN_FIFO0_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
+		       |(2 << AUDIN_FIFO0_CHAN)	/* two channel */
+		       |(0 << 16)	/* to DDR */
+		       |(1 << AUDIN_FIFO0_UG)	/* Urgent request. */
+		       |(0 << 17)	/* Overflow Interrupt mask */
+		       |(0 << 18)
+		       /* Audio in INT */
+		       /* |(1<<19)    // hold 0 enable */
+		       | (0 << AUDIN_FIFO0_UG)	/* hold0 to aififo */
+	    );
+
+	aml_write_cbus(AUDIN_FIFO0_CTRL1, 0 << 4	/* fifo0_dest_sel */
+		       | 2 << 2	/* fifo0_din_byte_num */
+		       | din_pos << 0);	/* fifo0_din_pos */
 
 	if (audio_in_source == 0) {
-		aml_audin_write(AUDIN_I2SIN_CTRL,
-				   ((0xf>>(4 - ch/2)) << I2SIN_CHAN_EN)
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
 				   | (3 << I2SIN_SIZE)
 				   | (1 << I2SIN_LRCLK_INVT)
 				   | (1 << I2SIN_LRCLK_SKEW)
@@ -249,9 +320,8 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode,
 				   | (!mode << I2SIN_LRCLK_SEL)
 				   | (!mode << I2SIN_CLK_SEL)
 				   | (!mode << I2SIN_DIR));
-
 	} else if (audio_in_source == 1) {
-		aml_audin_write(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
 				   | (0 << I2SIN_SIZE)
 				   | (0 << I2SIN_LRCLK_INVT)
 				   | (0 << I2SIN_LRCLK_SKEW)
@@ -259,18 +329,8 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size, u32 i2s_mode,
 				   | (0 << I2SIN_LRCLK_SEL)
 				   | (0 << I2SIN_CLK_SEL)
 				   | (0 << I2SIN_DIR));
-		if (is_meson_txlx_cpu()) {
-			/* adec */
-			aml_audin_write(AUDIN_ATV_DEMOD_CTRL, 7);
-			/* fifo source adec */
-			aml_audin_update_bits(AUDIN_FIFO0_CTRL,
-				   (0x7 << AUDIN_FIFO0_DIN_SEL),
-				   (ATV_ADEC << AUDIN_FIFO0_DIN_SEL));
-			aml_audin_update_bits(AUDIN_FIFO0_CTRL1, 0x3,
-							(0x1 << 0));
-		}
 	} else if (audio_in_source == 2) {
-		aml_audin_write(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
+		aml_write_cbus(AUDIN_I2SIN_CTRL, (1 << I2SIN_CHAN_EN)
 				   | (3 << I2SIN_SIZE)
 				   | (1 << I2SIN_LRCLK_INVT)
 				   | (1 << I2SIN_LRCLK_SKEW)
@@ -299,10 +359,10 @@ static void spdifin_reg_set(void)
 
 	pr_info("spdifin_reg_set: clk_rate=%d\n", clk_rate);
 
-	aml_audin_write(AUDIN_SPDIF_MODE,
-		       (aml_audin_read(AUDIN_SPDIF_MODE) & 0x7fffc000) |
+	aml_write_cbus(AUDIN_SPDIF_MODE,
+		       (aml_read_cbus(AUDIN_SPDIF_MODE) & 0x7fffc000) |
 		       (spdif_mode_14bit << 0));
-	aml_audin_write(AUDIN_SPDIF_FS_CLK_RLTN,
+	aml_write_cbus(AUDIN_SPDIF_FS_CLK_RLTN,
 		       (period_32k << 0) |
 		       (period_44k << 6) | (period_48k << 12) |
 		       /* Spdif_fs_clk_rltn */
@@ -312,57 +372,65 @@ static void spdifin_reg_set(void)
 
 static void spdifin_fifo1_set_buf(u32 addr, u32 size, u32 src)
 {
-	aml_audin_write(AUDIN_SPDIF_MODE,
-			   aml_audin_read(AUDIN_SPDIF_MODE) & 0x7fffffff);
-	aml_audin_write(AUDIN_FIFO1_START, addr & 0xffffffc0);
-	aml_audin_write(AUDIN_FIFO1_PTR, (addr & 0xffffffc0));
-	aml_audin_write(AUDIN_FIFO1_END,
+	aml_write_cbus(AUDIN_SPDIF_MODE,
+			   aml_read_cbus(AUDIN_SPDIF_MODE) & 0x7fffffff);
+	/*set channel invert from old spdif in mode*/
+	aml_cbus_update_bits(AUDIN_SPDIF_MODE, (1 << 19), (1 << 19));
+	aml_write_cbus(AUDIN_FIFO1_START, addr & 0xffffffc0);
+	aml_write_cbus(AUDIN_FIFO1_PTR, (addr & 0xffffffc0));
+	aml_write_cbus(AUDIN_FIFO1_END,
 		       (addr & 0xffffffc0) + (size & 0xffffffc0) - 8);
-	aml_audin_write(AUDIN_FIFO1_CTRL, (1 << AUDIN_FIFO1_EN)	/* FIFO0_EN */
+	aml_write_cbus(AUDIN_FIFO1_CTRL, (1 << AUDIN_FIFO1_EN)	/* FIFO0_EN */
 		       |(1 << AUDIN_FIFO1_LOAD)	/* load start address. */
 		       |(src << AUDIN_FIFO1_DIN_SEL)
-		       |(4 << AUDIN_FIFO1_ENDIAN) /* AUDIN_FIFO0_ENDIAN */
+
+		       /* DIN from i2sin. */
+		       /* |(1<<6)   // 32 bits data in. */
+		       /* |(0<<7)   // put the 24bits data to  low 24 bits */
+		       | (4 << AUDIN_FIFO1_ENDIAN)	/* AUDIN_FIFO0_ENDIAN */
 		       |(2 << AUDIN_FIFO1_CHAN)	/* 2 channel */
+		       |(0 << 16)	/* to DDR */
 		       |(1 << AUDIN_FIFO1_UG)	/* Urgent request. */
-	);
+		       |(0 << 17)	/* Overflow Interrupt mask */
+		       |(0 << 18)
+		       /* Audio in INT */
+		       /* |(1<<19)   //hold 0 enable */
+		       | (0 << AUDIN_FIFO1_UG)	/* hold0 to aififo */
+	    );
 
 	/*
 	 *  according clk81 to set reg spdif_mode(0x2800)
 	 *  the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
 	 */
 	spdifin_reg_set();
-
-	if (audio_in_source == 3)
-		src = SPDIF_IN;
-
 	/*3 byte mode, (23:0)*/
 	if (src == PAO_IN) {
-		aml_audin_write(AUDIN_FIFO1_CTRL1, 0x08);
+		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x08);
 	} else if (src == HDMI_IN) {
 		/* there are two inputs for HDMI_IN. New I2S:SPDIF */
-		aml_audin_write(AUDIN_FIFO1_CTRL1, 0x08);
+		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x08);
 		if (1) {
 			/* new SPDIF in module */
-			aml_audin_write(AUDIN_DECODE_FORMAT, 1<<24);
+			aml_write_cbus(AUDIN_DECODE_FORMAT, 1<<24);
 		} else {
 			/* new I2S in module */
-			aml_audin_write(AUDIN_DECODE_FORMAT, 0x103ad);
+			aml_write_cbus(AUDIN_DECODE_FORMAT, 0x103ad);
 		}
 	} else
-		aml_audin_write(AUDIN_FIFO1_CTRL1, 0x88);
+		aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
 }
 
 void audio_in_i2s_set_buf(u32 addr, u32 size,
-	u32 i2s_mode, u32 i2s_sync, u32 din_sel, u32 ch)
+	u32 i2s_mode, u32 i2s_sync, u32 din_sel)
 {
-	pr_debug("i2sin_fifo0_set_buf din_sel:%d ch:%d\n", din_sel, ch);
-	i2sin_fifo0_set_buf(addr, size, i2s_mode, i2s_sync, din_sel, ch);
+	pr_info("i2sin_fifo0_set_buf\n");
+	i2sin_fifo0_set_buf(addr, size, i2s_mode, i2s_sync, din_sel);
 	audio_in_buf_ready = 1;
 }
 
 void audio_in_spdif_set_buf(u32 addr, u32 size, u32 src)
 {
-	pr_debug("spdifin_fifo1_set_buf, src = %d\n", src);
+	pr_info("spdifin_fifo1_set_buf, src = %d\n", src);
 	spdifin_fifo1_set_buf(addr, size, src);
 }
 
@@ -375,19 +443,19 @@ void audio_in_i2s_enable(int flag)
 		/* reset only when start i2s input */
  reset_again:
 		/* reset FIFO 0 */
-		aml_audin_update_bits(AUDIN_FIFO0_CTRL, 0x2, 0x2);
-		aml_audin_write(AUDIN_FIFO0_PTR, 0);
-		rd = aml_audin_read(AUDIN_FIFO0_PTR);
-		start = aml_audin_read(AUDIN_FIFO0_START);
+		aml_cbus_update_bits(AUDIN_FIFO0_CTRL, 0x2, 0x2);
+		aml_write_cbus(AUDIN_FIFO0_PTR, 0);
+		rd = aml_read_cbus(AUDIN_FIFO0_PTR);
+		start = aml_read_cbus(AUDIN_FIFO0_START);
 		if (rd != start) {
 			pr_err("error %08x, %08x !\n",
 			       rd, start);
 			goto reset_again;
 		}
-		aml_audin_update_bits(AUDIN_I2SIN_CTRL, 1 << I2SIN_EN,
+		aml_cbus_update_bits(AUDIN_I2SIN_CTRL, 1 << I2SIN_EN,
 				     1 << I2SIN_EN);
 	} else {
-		aml_audin_update_bits(AUDIN_I2SIN_CTRL, 1 << I2SIN_EN,
+		aml_cbus_update_bits(AUDIN_I2SIN_CTRL, 1 << I2SIN_EN,
 				     0 << I2SIN_EN);
 	}
 }
@@ -399,36 +467,36 @@ void audio_in_spdif_enable(int flag)
 	if (flag) {
  reset_again:
 		/* reset FIFO 0 */
-		aml_audin_update_bits(AUDIN_FIFO1_CTRL, 0x2, 0x2);
-		aml_audin_write(AUDIN_FIFO1_PTR, 0);
-		rd = aml_audin_read(AUDIN_FIFO1_PTR);
-		start = aml_audin_read(AUDIN_FIFO1_START);
+		aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 0x2, 0x2);
+		aml_write_cbus(AUDIN_FIFO1_PTR, 0);
+		rd = aml_read_cbus(AUDIN_FIFO1_PTR);
+		start = aml_read_cbus(AUDIN_FIFO1_START);
 		if (rd != start) {
 			pr_err("error %08x, %08x !\n", rd, start);
 			goto reset_again;
 		}
-		aml_audin_write(AUDIN_SPDIF_MODE,
-			       aml_audin_read(AUDIN_SPDIF_MODE) | (1 << 31));
+		aml_write_cbus(AUDIN_SPDIF_MODE,
+			       aml_read_cbus(AUDIN_SPDIF_MODE) | (1 << 31));
 	} else {
-		aml_audin_write(AUDIN_SPDIF_MODE,
-			       aml_audin_read(AUDIN_SPDIF_MODE) & ~(1 << 31));
+		aml_write_cbus(AUDIN_SPDIF_MODE,
+			       aml_read_cbus(AUDIN_SPDIF_MODE) & ~(1 << 31));
 	}
 }
 
 int if_audio_in_i2s_enable(void)
 {
-	return aml_audin_read(AUDIN_I2SIN_CTRL) & (1 << 15);
+	return aml_read_cbus(AUDIN_I2SIN_CTRL) & (1 << 15);
 }
 
 int if_audio_in_spdif_enable(void)
 {
-	return aml_audin_read(AUDIN_SPDIF_MODE) & (1 << 31);
+	return aml_read_cbus(AUDIN_SPDIF_MODE) & (1 << 31);
 }
 
 unsigned int audio_in_i2s_rd_ptr(void)
 {
 	unsigned int val;
-	val = aml_audin_read(AUDIN_FIFO0_RDPTR);
+	val = aml_read_cbus(AUDIN_FIFO0_RDPTR);
 	pr_info("audio in i2s rd ptr: %x\n", val);
 	return val;
 }
@@ -436,7 +504,7 @@ unsigned int audio_in_i2s_rd_ptr(void)
 unsigned int audio_in_spdif_rd_ptr(void)
 {
 	unsigned int val;
-	val = aml_audin_read(AUDIN_FIFO1_RDPTR);
+	val = aml_read_cbus(AUDIN_FIFO1_RDPTR);
 	pr_info("audio in spdif rd ptr: %x\n", val);
 	return val;
 }
@@ -444,8 +512,8 @@ unsigned int audio_in_spdif_rd_ptr(void)
 unsigned int audio_in_i2s_wr_ptr(void)
 {
 	unsigned int val;
-	aml_audin_write(AUDIN_FIFO0_PTR, 1);
-	val = aml_audin_read(AUDIN_FIFO0_PTR);
+	aml_write_cbus(AUDIN_FIFO0_PTR, 1);
+	val = aml_read_cbus(AUDIN_FIFO0_PTR);
 	return (val) & (~0x3F);
 	/* return val&(~0x7); */
 }
@@ -453,76 +521,87 @@ unsigned int audio_in_i2s_wr_ptr(void)
 unsigned int audio_in_spdif_wr_ptr(void)
 {
 	unsigned int val;
-	aml_audin_write(AUDIN_FIFO1_PTR, 1);
-	val = aml_audin_read(AUDIN_FIFO1_PTR);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 1);
+	val = aml_read_cbus(AUDIN_FIFO1_PTR);
 	return (val) & (~0x3F);
 }
 
 void audio_in_i2s_set_wrptr(unsigned int val)
 {
-	aml_audin_write(AUDIN_FIFO0_RDPTR, val);
+	aml_write_cbus(AUDIN_FIFO0_RDPTR, val);
 }
 
 void audio_in_spdif_set_wrptr(unsigned int val)
 {
-	aml_audin_write(AUDIN_FIFO1_RDPTR, val);
+	aml_write_cbus(AUDIN_FIFO1_RDPTR, val);
 }
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 void audio_set_i2s_mode(u32 mode, unsigned int channel)
 {
-	aml_aiu_write(AIU_I2S_SOURCE_DESC, 0x800);
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x800);
+
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0);
 
 	if (8 == channel) {
-		aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 1);
 
 		if (mode == AIU_I2S_MODE_PCM32) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
 						7 << 6);
 		} else if (mode == AIU_I2S_MODE_PCM24) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			/* todo: to verify it */
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+						7 << 6);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+
 		} else if (mode == AIU_I2S_MODE_PCM16) {
-			/* todo: this mode still has problem*/
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
 						1 << 6);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 3 << 3,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
 						2 << 3);
+
+			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
 		}
 	} else if (2 == channel) {
-		aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
+		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
 
 		if (mode == AIU_I2S_MODE_PCM16) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
 						1 << 6);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 3 << 3,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
 						2 << 3);
 		} else if (mode == AIU_I2S_MODE_PCM24) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
-						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
+						2 << 3);
 		} else if (mode == AIU_I2S_MODE_PCM32) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
 						7 << 6);
 		}
 	}
 
 	/* In split mode, there are not mask control,
 	so aiu_mem_i2s_mask[15:0] must set 8'hffff_ffff. */
-	/*aml_aiu_write(AIU_MEM_I2S_MASKS,
+	/*aml_write_cbus(AIU_MEM_I2S_MASKS,
 		(16 << 16) |
 		(0xff << 8) |
 		(0xff << 0));*/
@@ -539,23 +618,23 @@ void audio_set_i2s_mode(u32 mode)
 
 	if (mode < sizeof(mask) / sizeof(unsigned short)) {
 		/* four two channels stream */
-		aml_aiu_write(AIU_I2S_SOURCE_DESC, 1);
+		aml_write_cbus(AIU_I2S_SOURCE_DESC, 1);
 
 		if (mode == AIU_I2S_MODE_PCM16) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6,
 					     1 << 6);
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5, 0);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5, 0);
 		} else if (mode == AIU_I2S_MODE_PCM32) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
 					     1 << 5);
 		} else if (mode == AIU_I2S_MODE_PCM24) {
-			aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
-			aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
 					     1 << 5);
 		}
 
-		aml_aiu_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
+		aml_cbus_update_bits(AIU_MEM_I2S_MASKS, 0xffff, mask[mode]);
 	}
 }
 #endif
@@ -568,55 +647,90 @@ void audio_set_i2s_mode(u32 mode)
  *  This is dolby digital plus's spec
  */
 
+void audio_util_set_dac_format(unsigned format)
+{
+	/* 958 divisor more, if true, divided by 2, 4, 6, 8. */
+	aml_write_cbus(AIU_CLK_CTRL, (0 << 12) |
+	/* alrclk skew: 1=alrclk transitions on the cycle before msb is sent */
+		       (1 << 8) |
+		       (1 << 6) |
+	/* invert aoclk */
+		       (1 << 7) |
+	/* invert lrclk */
+#if OVERCLOCK == 1
+	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		       (1 << 4) |
+	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
+		       (3 << 2) |
+#else
+	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		       (1 << 4) |
+	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
+		       (2 << 2) |
+#endif
+		       (1 << 1) |	/* enable 958 clock */
+		       (1 << 0));	/* enable I2S clock */
+	if (format == AUDIO_ALGOUT_DAC_FORMAT_DSP)
+		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
+	else if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY)
+		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 0);
+
+	if (dac_mute_const == 0x800000)
+		aml_write_cbus(AIU_I2S_DAC_CFG, 0x000f);
+	else
+		/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
+		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);	/* four 2-channel */
+}
+
 /* iec958 and i2s clock are separated after M6TV. */
 void audio_util_set_dac_958_format(unsigned format)
 {
 	/* 958 divisor more, if true, divided by 2, 4, 6, 8 */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 12, 0);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 12, 0);
 #if IEC958_OVERCLOCK == 1
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-/*	aml_aiu_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);  */
+/*	aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);  */
 #else
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-/*	aml_aiu_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);  */
+/*	aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);  */
 #endif
 	/* enable 958 divider */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 }
 
-void audio_util_set_i2s_format(unsigned format)
+void audio_util_set_dac_i2s_format(unsigned format)
 {
 	/* invert aoclk */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 6, 1 << 6);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 6, 1 << 6);
 	/* invert lrclk */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 7, 1 << 7);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 7, 1 << 7);
 	/* alrclk skew: 1=alrclk transitions on the cycle before msb is sent */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
-#if MCLKFS_RATIO == 512
+	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 1 << 8);
+#if OVERCLOCK == 1
 	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 0x3 << 2, 0x3 << 2);
-#elif MCLKFS_RATIO == 256
-	aml_aiu_update_bits(AIU_CLK_CTRL, 0x3 << 2, 0x2 << 2);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 2, 0x3 << 2);
 #else
-	aml_aiu_update_bits(AIU_CLK_CTRL, 0x3 << 2, 0x1 << 2);
+	/* i2s divisor: 0=no div; 1=div by 2; 2=div by 4; 3=div by 8. */
+	aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 2, 0x2 << 2);
 #endif
 	/* enable I2S clock */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1, 1);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1, 1);
 
 	if (format == AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY)
-		aml_aiu_update_bits(AIU_CLK_CTRL, 0x3 << 8, 0);
+		aml_cbus_update_bits(AIU_CLK_CTRL, 0x3 << 8, 0);
 
 	if (dac_mute_const == 0x800000)
-		aml_aiu_write(AIU_I2S_DAC_CFG, 0x000f);
+		aml_write_cbus(AIU_I2S_DAC_CFG, 0x000f);
 	else
 		/* Payload 24-bit, Msb first, alrclk = aoclk/64 */
-		aml_aiu_write(AIU_I2S_DAC_CFG, 0x0007);
+		aml_write_cbus(AIU_I2S_DAC_CFG, 0x0007);
 
 	/* four 2-channel */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	aml_aiu_update_bits(AIU_I2S_SOURCE_DESC, 1 << 11, 1 << 11);
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, (1 << 11));
 #else
-	aml_aiu_write(AIU_I2S_SOURCE_DESC, 0x0001);
+	aml_write_cbus(AIU_I2S_SOURCE_DESC, 0x0001);
 #endif
 }
 
@@ -624,40 +738,35 @@ void audio_util_set_i2s_format(unsigned format)
 void audio_set_i2s_clk_div(void)
 {
 	/* aiclk source */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 10, 1 << 10);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 10, 1 << 10);
 	/* Set mclk over sclk ratio */
-	aml_aiu_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x3f << 8, (4 - 1) << 8);
 	/* set dac/adc lrclk ratio over sclk----64fs */
-	aml_aiu_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
-	aml_aiu_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_DAC_LRCLK_CTRL, 0xfff, (64 - 1));
+	aml_cbus_update_bits(AIU_CODEC_ADC_LRCLK_CTRL, 0xfff, (64 - 1));
 	/* Enable sclk */
-	aml_aiu_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
+	aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 14, 1 << 14);
 }
 
-void audio_set_spdif_clk_div(uint div)
+void audio_set_spdif_clk_div(void)
 {
-	uint val = 0;
-	if (div < 1 && div > 4)
-		return;
-
-	val = div - 1;
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 3 << 4, val << 4);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
 	/* enable 958 divider */
-	aml_aiu_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 }
 
 void audio_enable_ouput(int flag)
 {
 	if (flag) {
-		aml_aiu_write(AIU_RST_SOFT, 0x05);
-		aml_aiu_read(AIU_I2S_SYNC);
-		aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 3 << 1, 3 << 1);
+		aml_write_cbus(AIU_RST_SOFT, 0x05);
+		aml_read_cbus(AIU_I2S_SYNC);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 3 << 1, 3 << 1);
 
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
-		aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 3 << 1, 0);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 3 << 1, 0);
 
 		/* Maybe cause POP noise */
 		/* audio_i2s_mute(); */
@@ -667,102 +776,104 @@ void audio_enable_ouput(int flag)
 
 int if_audio_out_enable(void)
 {
-	return aml_aiu_read(AIU_MEM_I2S_CONTROL) & (0x3 << 1);
+	return aml_read_cbus(AIU_MEM_I2S_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_audio_out_enable);
 
 int if_958_audio_out_enable(void)
 {
-	return aml_aiu_read(AIU_MEM_IEC958_CONTROL) & (0x3 << 1);
+	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (0x3 << 1);
 }
 EXPORT_SYMBOL(if_958_audio_out_enable);
 
 unsigned int read_i2s_rd_ptr(void)
 {
 	unsigned int val;
-	val = aml_aiu_read(AIU_MEM_I2S_RD_PTR);
+	val = aml_read_cbus(AIU_MEM_I2S_RD_PTR);
 	return val;
 }
 
 unsigned int read_iec958_rd_ptr(void)
 {
 	unsigned int val;
-	val = aml_aiu_read(AIU_MEM_IEC958_RD_PTR);
+	val = aml_read_cbus(AIU_MEM_IEC958_RD_PTR);
 	return val;
 }
 
 void aml_audio_i2s_unmute(void)
 {
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0);
 }
 
 void aml_audio_i2s_mute(void)
 {
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xff << 8);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xff << 8);
 }
 
 void audio_i2s_unmute(void)
 {
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0);
-	aml_aiu_update_bits(AIU_958_CTRL, 0x3 << 3, 0 << 3);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0);
+	aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 3, 0 << 3);
 }
 
 void audio_i2s_mute(void)
 {
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xff << 8);
-	aml_aiu_update_bits(AIU_958_CTRL, 0x3 << 3, 0x3 << 3);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0xff << 8, 0xff << 8);
+	aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 3, 0x3 << 3);
 }
 
 void audio_mute_left_right(unsigned flag)
 {
 	if (flag == 0) {	/* right */
-		aml_aiu_update_bits(AIU_958_CTRL, 0x3 << 3, 0x1 << 3);
+		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 3, 0x1 << 3);
 	} else if (flag == 1) {	/* left */
-		aml_aiu_update_bits(AIU_958_CTRL, 0x3 << 3, 0x2 << 3);
+		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 3, 0x2 << 3);
 	}
 }
 
 void audio_hw_958_reset(unsigned slow_domain, unsigned fast_domain)
 {
-	aml_aiu_write(AIU_958_DCU_FF_CTRL, 0);
-	aml_aiu_write(AIU_RST_SOFT, (slow_domain << 3) | (fast_domain << 2));
+	aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
+	aml_write_cbus(AIU_RST_SOFT, (slow_domain << 3) | (fast_domain << 2));
 }
 
 void audio_hw_958_raw(void)
 {
-	aml_aiu_write(AIU_958_MISC, 1);
-	/* raw */
-	aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 1 << 8);
-	/* 8bit */
-	aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
-	/* endian */
-	aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 0x7 << 3, 1 << 3);
-
-	aml_aiu_write(AIU_958_BPF, IEC958_bpf);
-	aml_aiu_write(AIU_958_BRST, IEC958_brst);
-	aml_aiu_write(AIU_958_LENGTH, IEC958_length);
-	aml_aiu_write(AIU_958_PADDSIZE, IEC958_padsize);
+	if (ENABLE_IEC958) {
+		aml_write_cbus(AIU_958_MISC, 1);
+		/* raw */
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 1 << 8);
+		/* 8bit */
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
+		/* endian */
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x7 << 3, 1 << 3);
+	}
+
+	aml_write_cbus(AIU_958_BPF, IEC958_bpf);
+	aml_write_cbus(AIU_958_BRST, IEC958_brst);
+	aml_write_cbus(AIU_958_LENGTH, IEC958_length);
+	aml_write_cbus(AIU_958_PADDSIZE, IEC958_padsize);
 	/* disable int */
-	aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 0x3 << 2, 0);
+	aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 0x3 << 2, 0);
 
 	if (IEC958_mode == 1) {	/* search in byte */
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0x7 << 4);
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0x7 << 4);
 	} else if (IEC958_mode == 2) {	/* search in word */
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0x5 << 4);
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0x5 << 4);
 	} else {
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0);
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 0x7 << 4, 0);
 	}
-	aml_aiu_write(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
-	aml_aiu_write(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
-	aml_aiu_write(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
-	aml_aiu_write(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
-
-	aml_aiu_write(AIU_958_SYNWORD1, IEC958_syncword1);
-	aml_aiu_write(AIU_958_SYNWORD2, IEC958_syncword2);
-	aml_aiu_write(AIU_958_SYNWORD3, IEC958_syncword3);
-	aml_aiu_write(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
-	aml_aiu_write(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
-	aml_aiu_write(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
+	aml_write_cbus(AIU_958_CHSTAT_L0, IEC958_chstat0_l);
+	aml_write_cbus(AIU_958_CHSTAT_L1, IEC958_chstat1_l);
+	aml_write_cbus(AIU_958_CHSTAT_R0, IEC958_chstat0_r);
+	aml_write_cbus(AIU_958_CHSTAT_R1, IEC958_chstat1_r);
+
+	aml_write_cbus(AIU_958_SYNWORD1, IEC958_syncword1);
+	aml_write_cbus(AIU_958_SYNWORD2, IEC958_syncword2);
+	aml_write_cbus(AIU_958_SYNWORD3, IEC958_syncword3);
+	aml_write_cbus(AIU_958_SYNWORD1_MASK, IEC958_syncword1_mask);
+	aml_write_cbus(AIU_958_SYNWORD2_MASK, IEC958_syncword2_mask);
+	aml_write_cbus(AIU_958_SYNWORD3_MASK, IEC958_syncword3_mask);
 
 	pr_info("%s: %d\n", __func__, __LINE__);
 	pr_info("\tBPF: %x\n", IEC958_bpf);
@@ -777,17 +888,17 @@ void audio_hw_958_raw(void)
 void set_958_channel_status(struct _aiu_958_channel_status_t *set)
 {
 	if (set) {
-		aml_aiu_write(AIU_958_CHSTAT_L0, set->chstat0_l);
-		aml_aiu_write(AIU_958_CHSTAT_L1, set->chstat1_l);
-		aml_aiu_write(AIU_958_CHSTAT_R0, set->chstat0_r);
-		aml_aiu_write(AIU_958_CHSTAT_R1, set->chstat1_r);
+		aml_write_cbus(AIU_958_CHSTAT_L0, set->chstat0_l);
+		aml_write_cbus(AIU_958_CHSTAT_L1, set->chstat1_l);
+		aml_write_cbus(AIU_958_CHSTAT_R0, set->chstat0_r);
+		aml_write_cbus(AIU_958_CHSTAT_R1, set->chstat1_r);
 	}
 }
 
 static void audio_hw_set_958_pcm24(struct _aiu_958_raw_setting_t *set)
 {
 	/* in pcm mode, set bpf to 128 */
-	aml_aiu_write(AIU_958_BPF, 0x80);
+	aml_write_cbus(AIU_958_BPF, 0x80);
 	set_958_channel_status(set->chan_stat);
 }
 
@@ -795,78 +906,85 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 {
 	if (mode == AIU_958_MODE_PCM_RAW) {
 		mode = AIU_958_MODE_PCM16;	/* use 958 raw pcm mode */
-		aml_aiu_write(AIU_958_VALID_CTRL, 3);
+		aml_write_cbus(AIU_958_VALID_CTRL, 3);
 	} else
-		aml_aiu_write(AIU_958_VALID_CTRL, 0);
+		aml_write_cbus(AIU_958_VALID_CTRL, 0);
 
 	if (mode == AIU_958_MODE_RAW) {
 
 		audio_hw_958_raw();
-		aml_aiu_write(AIU_958_MISC, 1);
-		/* raw */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     1 << 8, 1 << 8);
-		/* 8bit */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
-		/* endian */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     0x7 << 3, 0x1 << 3);
+		if (ENABLE_IEC958) {
+			aml_write_cbus(AIU_958_MISC, 1);
+			/* raw */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     1 << 8, 1 << 8);
+			/* 8bit */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
+			/* endian */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     0x7 << 3, 0x1 << 3);
+		}
 
 		pr_info("IEC958 RAW\n");
 	} else if (mode == AIU_958_MODE_PCM32) {
 		audio_hw_set_958_pcm24(set);
+		if (ENABLE_IEC958) {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_958_MISC, 0x3480);
-		/* pcm */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
-					1 << 8);
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
 #else
-		aml_aiu_write(AIU_958_MISC, 0x2020 | (1 << 7));
-		/* pcm */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
 #endif
-		/* 16bit */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
-		/* endian */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     0x7 << 3, 0);
-
+			/* 16bit */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
+			/* endian */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     0x7 << 3, 0);
+		}
 		pr_info("IEC958 PCM32\n");
 	} else if (mode == AIU_958_MODE_PCM24) {
 		audio_hw_set_958_pcm24(set);
+		if (ENABLE_IEC958) {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_write(AIU_958_MISC, 0x3480);
-		/* pcm */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
-					1 << 8);
+			aml_write_cbus(AIU_958_MISC, 0x3480);
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
 #else
-		aml_aiu_write(AIU_958_MISC, 0x2020 | (1 << 7));
-		/* pcm */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+			aml_write_cbus(AIU_958_MISC, 0x2020 | (1 << 7));
+			/* pcm */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
 #endif
-		/* 16bit */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
-		/* endian */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     0x7 << 3, 0);
+			/* 16bit */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 7, 0);
+			/* endian */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     0x7 << 3, 0);
 
+		}
 		pr_info("IEC958 24bit\n");
 	} else if (mode == AIU_958_MODE_PCM16) {
 		audio_hw_set_958_pcm24(set);
-		aml_aiu_write(AIU_958_MISC, 0x2042);
-		/* pcm */
+		if (ENABLE_IEC958) {
+			aml_write_cbus(AIU_958_MISC, 0x2042);
+			/* pcm */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
-					1 << 8);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
+						1 << 8);
 #else
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8, 0);
 #endif
-		/* 16bit */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     1 << 7, 1 << 7);
-		/* endian */
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL,
-				     0x7 << 3, 0);
+			/* 16bit */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     1 << 7, 1 << 7);
+			/* endian */
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL,
+					     0x7 << 3, 0);
+		}
 		pr_info("IEC958 16bit\n");
 	}
 
@@ -874,22 +992,22 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 	if (mode == AIU_958_MODE_PCM32)
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1 << 8, 1 << 8);
 #endif
 
-	aml_aiu_write(AIU_958_FORCE_LEFT, 1);
+	aml_write_cbus(AIU_958_FORCE_LEFT, 1);
 }
 
 void audio_out_i2s_enable(unsigned flag)
 {
 	if (flag) {
-		aml_aiu_write(AIU_RST_SOFT, 0x01);
-		aml_aiu_read(AIU_I2S_SYNC);
-		aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0x3 << 1);
+		aml_write_cbus(AIU_RST_SOFT, 0x01);
+		aml_read_cbus(AIU_I2S_SYNC);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0x3 << 1);
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
-		aml_aiu_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
+		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
 
 		/* Maybe cause POP noise */
 		/* audio_i2s_mute(); */
@@ -899,56 +1017,50 @@ void audio_out_i2s_enable(unsigned flag)
 
 void audio_hw_958_enable(unsigned flag)
 {
-	if (flag) {
-		aml_aiu_write(AIU_RST_SOFT, 0x04);
-		aml_aiu_write(AIU_958_FORCE_LEFT, 0);
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 1, 1);
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
-				     0x3 << 1);
-	} else {
-		aml_aiu_write(AIU_RST_SOFT, 0x04);
-		aml_aiu_write(AIU_958_FORCE_LEFT, 0);
-		aml_aiu_write(AIU_958_DCU_FF_CTRL, 0);
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
-				     0);
+	if (ENABLE_IEC958) {
+		if (flag) {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
+			aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1, 1);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
+					     0x3 << 1);
+		} else {
+			aml_write_cbus(AIU_RST_SOFT, 0x04);
+			aml_write_cbus(AIU_958_FORCE_LEFT, 0);
+			aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
+			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
+					     0);
+		}
 	}
 }
 
 unsigned int read_i2s_mute_swap_reg(void)
 {
 	unsigned int val;
-	val = aml_aiu_read(AIU_I2S_MUTE_SWAP);
+	val = aml_read_cbus(AIU_I2S_MUTE_SWAP);
 	return val;
 }
 
 void audio_i2s_swap_left_right(unsigned int flag)
 {
     /*only LPCM output can set aiu hw channel swap*/
-	if (IEC958_mode_codec == 0 || IEC958_mode_codec == 9)
-		aml_aiu_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
+	if (ENABLE_IEC958 && (IEC958_mode_codec == 0 || IEC958_mode_codec == 9))
+		aml_cbus_update_bits(AIU_958_CTRL, 0x3 << 1, flag << 1);
 
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
-	aml_aiu_update_bits(AIU_I2S_MUTE_SWAP, 0x3 << 2, flag << 2);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3, flag);
+	aml_cbus_update_bits(AIU_I2S_MUTE_SWAP, 0x3 << 2, flag << 2);
 }
 
 void audio_i2s_958_same_source(unsigned int same)
 {
-	aml_aiu_update_bits(AIU_I2S_MISC, 1 << 3, (!!same) << 3);
+	aml_cbus_update_bits(AIU_I2S_MISC, 1 << 3, (!!same) << 3);
 }
 
 void set_hw_resample_source(int source)
 {
-	aml_eqdrc_update_bits(AUD_RESAMPLE_CTRL0, 1 << 29, source << 29);
+	aml_cbus_update_bits(AUD_RESAMPLE_CTRL0, 1 << 29, source << 29);
 }
 EXPORT_SYMBOL(set_hw_resample_source);
-
-/*1: select pcm data/clk; 2: select AIU i2s data/clk*/
-void set_hdmi_tx_clk_source(int source)
-{
-	aml_aiu_update_bits(AIU_HDMI_CLK_DATA_CTRL, 0x3, source);
-	aml_aiu_update_bits(AIU_HDMI_CLK_DATA_CTRL, 0x3 << 4, source << 4);
-}
-
 #if 0
 unsigned int audio_hdmi_init_ready(void)
 {
@@ -959,13 +1071,13 @@ unsigned int audio_hdmi_init_ready(void)
 unsigned audio_spdifout_pg_enable(unsigned char enable)
 {
 	if (enable) {
-		aml_aiu_update_bits(MPLL_958_CNTL, 1, 14, 1);
+		aml_cbus_update_bits(MPLL_958_CNTL, 1, 14, 1);
 		AUDIO_CLK_GATE_ON(AIU_IEC958);
 		AUDIO_CLK_GATE_ON(AIU_ICE958_AMCLK);
 	} else {
 		AUDIO_CLK_GATE_OFF(AIU_IEC958);
 		AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);
-		aml_aiu_update_bits(MPLL_958_CNTL, 0, 14, 1);
+		aml_cbus_update_bits(MPLL_958_CNTL, 0, 14, 1);
 	}
 	return 0;
 }
diff --git a/sound/soc/aml/m8/aml_audio_hw.h b/sound/soc/aml/m8/aml_audio_hw.h
index 6b31840..7c53cf2 100644
--- a/sound/soc/aml/m8/aml_audio_hw.h
+++ b/sound/soc/aml/m8/aml_audio_hw.h
@@ -111,14 +111,16 @@ enum {
 #define AUDIO_ALGOUT_DAC_FORMAT_DSP             0
 #define AUDIO_ALGOUT_DAC_FORMAT_LEFT_JUSTIFY    1
 
+extern unsigned ENABLE_IEC958;
 extern unsigned IEC958_MODE;
 extern unsigned I2S_MODE;
 extern unsigned audio_in_source;
 
+void set_i2s_source(unsigned source);
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel);
 void audio_set_958outbuf(u32 addr, u32 size, int flag);
 void audio_in_i2s_set_buf(u32 addr, u32 size,
-	u32 i2s_mode, u32 i2s_sync, u32 din_sel, u32 ch);
+	u32 i2s_mode, u32 i2s_sync, u32 din_sel);
 void audio_in_spdif_set_buf(u32 addr, u32 size, u32 src);
 void audio_in_i2s_enable(int flag);
 void audio_in_spdif_enable(int flag);
@@ -131,14 +133,15 @@ void audio_set_i2s_mode(u32 mode, unsigned int channel);
 void audio_set_i2s_mode(u32 mode);
 #endif
 void audio_set_i2s_clk_div(void);
-void audio_set_spdif_clk_div(uint div);
+void audio_set_spdif_clk_div(void);
 void audio_enable_ouput(int flag);
 unsigned int read_i2s_rd_ptr(void);
 void audio_i2s_unmute(void);
 void audio_i2s_mute(void);
 void aml_audio_i2s_unmute(void);
 void aml_audio_i2s_mute(void);
-void audio_util_set_i2s_format(unsigned format);
+void audio_util_set_dac_format(unsigned format);
+void audio_util_set_dac_i2s_format(unsigned format);
 void audio_util_set_dac_958_format(unsigned format);
 void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set);
 unsigned int read_i2s_mute_swap_reg(void);
@@ -149,6 +152,7 @@ int if_audio_in_spdif_enable(void);
 void audio_out_i2s_enable(unsigned flag);
 void audio_hw_958_enable(unsigned flag);
 void audio_out_enabled(int flag);
+void audio_util_set_dac_format(unsigned format);
 unsigned int audio_hdmi_init_ready(void);
 unsigned int read_iec958_rd_ptr(void);
 void audio_in_spdif_enable(int flag);
@@ -156,30 +160,20 @@ unsigned audio_spdifout_pg_enable(unsigned char enable);
 unsigned audio_aiu_pg_enable(unsigned char enable);
 void audio_mute_left_right(unsigned flag);
 void audio_i2s_958_same_source(unsigned int same);
-void set_hdmi_tx_clk_source(int source);
 
 extern unsigned int IEC958_mode_codec;
 extern unsigned int clk81;
 
-/*OVERCLOCK == 1, our SOC privide 512fs mclk;
-  DOWNCLOCK == 1, 128fs;
-  normal mclk : 256fs */
+/*OVERCLOCK == 1,our SOC privide 512fs mclk,OVERCLOCK == 0 ,256fs*/
 #define OVERCLOCK 0
-#define DOWNCLOCK 0
-
 #define IEC958_OVERCLOCK 1
 
 #if (OVERCLOCK == 1)
 #define MCLKFS_RATIO 512
-#elif (DOWNCLOCK == 1)
-#define MCLKFS_RATIO 128
 #else
 #define MCLKFS_RATIO 256
 #endif
 
-#define DEFAULT_SAMPLERATE 48000
-#define DEFAULT_MCLK_RATIO_SR MCLKFS_RATIO
-
 #define I2S_PLL_SRC         1	/* MPLL0 */
 #define MPLL_I2S_CNTL		HHI_MPLL_MP0
 
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm.c b/sound/soc/aml/m8/aml_audio_hw_pcm.c
index ada1959..7beaee8 100644
--- a/sound/soc/aml/m8/aml_audio_hw_pcm.c
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm.c
@@ -26,9 +26,10 @@
 
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 #include "aml_audio_hw_pcm.h"
 
+#include <linux/amlogic/sound/aiu_regs.h>
+
 static unsigned int pcmin_buffer_addr;
 static unsigned int pcmin_buffer_size;
 
@@ -49,36 +50,36 @@ int valid_channel[] = {
 	0x7ff,    /* slot number 11 */
 	0xfff,    /* slot number 12 */
 	0x1fff,    /* slot number 13 */
-	0x3fff,    /* slot number 14 */
-	0x7fff,    /* slot number 15 */
-	0xffff    /* slot number 16 */
+	0x2fff,    /* slot number 14 */
+	0x3fff,    /* slot number 15 */
+	0x7fff    /* slot number 16 */
 };
 
-static uint32_t aml_audin_read_bits(uint32_t reg, const uint32_t start,
+static uint32_t aml_read_cbus_bits(uint32_t reg, const uint32_t start,
 				   const uint32_t len)
 {
-	return (aml_audin_read(reg) >> start) & ((1L << len) - 1);
+	return (aml_read_cbus(reg) >> start) & ((1L << len) - 1);
 }
 
 static void pcm_in_register_show(void)
 {
 	pr_debug("PCMIN registers show:\n");
 	pr_debug("\tAUDIN_FIFO1_START(0x%04x): 0x%08x\n", AUDIN_FIFO1_START,
-		  aml_audin_read(AUDIN_FIFO1_START));
+		  aml_read_cbus(AUDIN_FIFO1_START));
 	pr_debug("\tAUDIN_FIFO1_END(0x%04x):   0x%08x\n", AUDIN_FIFO1_END,
-		  aml_audin_read(AUDIN_FIFO1_END));
+		  aml_read_cbus(AUDIN_FIFO1_END));
 	pr_debug("\tAUDIN_FIFO1_PTR(0x%04x):   0x%08x\n", AUDIN_FIFO1_PTR,
-		  aml_audin_read(AUDIN_FIFO1_PTR));
+		  aml_read_cbus(AUDIN_FIFO1_PTR));
 	pr_debug("\tAUDIN_FIFO1_RDPTR(0x%04x): 0x%08x\n", AUDIN_FIFO1_RDPTR,
-		  aml_audin_read(AUDIN_FIFO1_RDPTR));
+		  aml_read_cbus(AUDIN_FIFO1_RDPTR));
 	pr_debug("\tAUDIN_FIFO1_CTRL(0x%04x):  0x%08x\n", AUDIN_FIFO1_CTRL,
-		  aml_audin_read(AUDIN_FIFO1_CTRL));
+		  aml_read_cbus(AUDIN_FIFO1_CTRL));
 	pr_debug("\tAUDIN_FIFO1_CTRL1(0x%04x): 0x%08x\n", AUDIN_FIFO1_CTRL1,
-		  aml_audin_read(AUDIN_FIFO1_CTRL1));
+		  aml_read_cbus(AUDIN_FIFO1_CTRL1));
 	pr_debug("\tPCMIN_CTRL0(0x%04x):       0x%08x\n", PCMIN_CTRL0,
-		  aml_audin_read(PCMIN_CTRL0));
+		  aml_read_cbus(PCMIN_CTRL0));
 	pr_debug("\tPCMIN_CTRL1(0x%04x):       0x%08x\n", PCMIN_CTRL1,
-		  aml_audin_read(PCMIN_CTRL1));
+		  aml_read_cbus(PCMIN_CTRL1));
 }
 
 void pcm_master_in_enable(struct snd_pcm_substream *substream, int flag)
@@ -97,23 +98,22 @@ void pcm_master_in_enable(struct snd_pcm_substream *substream, int flag)
 
 	/* reset fifo */
 RESET_FIFO:
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
-	aml_audin_write(AUDIN_FIFO1_PTR, 0);
-	if (aml_audin_read(AUDIN_FIFO1_PTR) !=
-			aml_audin_read(AUDIN_FIFO1_START))
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 0);
+	if (aml_read_cbus(AUDIN_FIFO1_PTR) != aml_read_cbus(AUDIN_FIFO1_START))
 		goto RESET_FIFO;
 
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
 
 	/* reset pcmin */
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
 
 	/* disable fifo */
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
 
 	/* disable pcmin */
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
 
 	if (flag) {
 		unsigned pcm_mode = 1;
@@ -136,13 +136,13 @@ RESET_FIFO:
 		}
 
 		/* set buffer start ptr end */
-		aml_audin_write(AUDIN_FIFO1_START, pcmin_buffer_addr);
-		aml_audin_write(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
-		aml_audin_write(AUDIN_FIFO1_END,
+		aml_write_cbus(AUDIN_FIFO1_START, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_END,
 			pcmin_buffer_addr + pcmin_buffer_size - 8);
 
 		/* fifo control */
-		aml_audin_write(AUDIN_FIFO1_CTRL,
+		aml_write_cbus(AUDIN_FIFO1_CTRL,
 			(1 << 15) |    /* urgent request */
 			(1 << 11) |    /* channel */
 			(6 << 8) |     /* endian */
@@ -153,7 +153,7 @@ RESET_FIFO:
 		);
 
 		/* fifo control1 */
-		aml_audin_write(AUDIN_FIFO1_CTRL1,
+		aml_write_cbus(AUDIN_FIFO1_CTRL1,
 			/* data destination DDR */
 			(0 << 4) |
 			/* fifo1 din byte num.  00 : 1 byte. 01: 2 bytes.
@@ -164,7 +164,7 @@ RESET_FIFO:
 		);
 
 		/* pcmin control1 */
-		aml_audin_write(PCMIN_CTRL1,
+		aml_write_cbus(PCMIN_CTRL1,
 			/* pcmin SRC sel */
 			(0 << 29) |
 			/* pcmin clock sel */
@@ -180,7 +180,7 @@ RESET_FIFO:
 		);
 
 		/* pcmin control0 */
-		aml_audin_write(PCMIN_CTRL0,
+		aml_write_cbus(PCMIN_CTRL0,
 			/* pcmin enable */
 			(1 << 31) |
 			/* sync on clock posedge */
@@ -201,16 +201,16 @@ RESET_FIFO:
 		);
 
 		if (!pcm_out_is_enable()) {
-			aml_audin_write(PCMOUT_CTRL2,
-				aml_audin_read(PCMOUT_CTRL2) |
+			aml_write_cbus(PCMOUT_CTRL2,
+				aml_read_cbus(PCMOUT_CTRL2) |
 				/* pcmo max slot number in one frame*/
 				(0xF << 22) |
 				/* pcmo max bit number in one slot*/
 				(0xF << 16) |
 				(valid_slot << 0)
 			);
-			aml_audin_write(PCMOUT_CTRL1,
-				aml_audin_read(PCMOUT_CTRL1) |
+			aml_write_cbus(PCMOUT_CTRL1,
+				aml_read_cbus(PCMOUT_CTRL1) |
 				/* use posedge of PCM clock to output data*/
 				(0 << 28) |
 				/* invert fs phase */
@@ -227,8 +227,8 @@ RESET_FIFO:
 				/* fs_o end postion slot bit counter number.*/
 				(1 << 0)
 			);
-			aml_audin_write(PCMOUT_CTRL0,
-				aml_audin_read(PCMOUT_CTRL0) |
+			aml_write_cbus(PCMOUT_CTRL0,
+				aml_read_cbus(PCMOUT_CTRL0) |
 				(1 << 31) |     /* enable */
 				(1 << 29)     /* master */
 			);
@@ -236,7 +236,7 @@ RESET_FIFO:
 	} else {
 		if (!pcm_out_is_enable()) {
 			/* disable pcmout */
-			aml_audin_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+			aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
 		}
 	}
 
@@ -249,33 +249,32 @@ void pcm_in_enable(int flag)
 {
 	/* reset fifo */
  RESET_FIFO:
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
-	aml_audin_write(AUDIN_FIFO1_PTR, 0);
-	if (aml_audin_read(AUDIN_FIFO1_PTR) !=
-			aml_audin_read(AUDIN_FIFO1_START))
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 1 << 1);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 0);
+	if (aml_read_cbus(AUDIN_FIFO1_PTR) != aml_read_cbus(AUDIN_FIFO1_START))
 		goto RESET_FIFO;
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1 << 1, 0 << 1);
 
 	/* reset pcmin */
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 30, 0 << 30);
 
 	/* disable fifo */
-	aml_audin_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
+	aml_cbus_update_bits(AUDIN_FIFO1_CTRL, 1, 0);
 
 	/* disable pcmin */
-	aml_audin_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
+	aml_cbus_update_bits(PCMIN_CTRL0, 1 << 31, 0 << 31);
 
 	if (flag) {
 		/* set buffer start ptr end */
-		aml_audin_write(AUDIN_FIFO1_START, pcmin_buffer_addr);
-		aml_audin_write(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
-		aml_audin_write(AUDIN_FIFO1_END,
+		aml_write_cbus(AUDIN_FIFO1_START, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_PTR, pcmin_buffer_addr);
+		aml_write_cbus(AUDIN_FIFO1_END,
 			       pcmin_buffer_addr + pcmin_buffer_size - 8);
 
 		/* fifo control */
 		/* urgent request */
-		aml_audin_write(AUDIN_FIFO1_CTRL, (1 << 15) |
+		aml_write_cbus(AUDIN_FIFO1_CTRL, (1 << 15) |
 			       (1 << 11) |	/* channel */
 			       (6 << 8) |	/* endian */
 			       /* (0 << 8) |     // endian */
@@ -287,35 +286,32 @@ void pcm_in_enable(int flag)
 
 		/* fifo control1 */
 		/* data destination DDR */
-		aml_audin_write(AUDIN_FIFO1_CTRL1, (0 << 4) |
+		aml_write_cbus(AUDIN_FIFO1_CTRL1, (0 << 4) |
 			       (1 << 2) |	/* 16bits */
 			       (0 << 0)	/* data position */
 		    );
 
 		/* pcmin control1 */
-		aml_audin_write(PCMIN_CTRL1,
-			(0 << 29) |	/* external chip */
-			(0 << 28) |	/* external chip */
-			/* using negedge of PCM clock to latch the input data */
-			(1 << 27) |
-			(15 << 21) |	/* slot bit msb 16 clocks per slot */
-			(15 << 16) |	/* data msb 16bits data */
-			(1 << 0)	/* slot valid */
-			);
+		aml_write_cbus(PCMIN_CTRL1, (0 << 29) |	/* external chip */
+	       (0 << 28) |	/* external chip */
+		/* using negedge of PCM clock to latch the input data */
+	       (1 << 27) |
+	       (15 << 21) |	/* slot bit msb 16 clocks per slot */
+	       (15 << 16) |	/* data msb 16bits data */
+	       (1 << 0)	/* slot valid */
+		    );
 
 		/* pcmin control0 */
-		aml_audin_write(PCMIN_CTRL0,
-			(1 << 31) |	/* pcmin enable */
-			(1 << 29) |	/* sync on clock posedge */
-			(0 << 16) |	/* FS SKEW */
+		aml_write_cbus(PCMIN_CTRL0, (1 << 31) |	/* pcmin enable */
+	       (1 << 29) |	/* sync on clock posedge */
+	       (0 << 16) |	/* FS SKEW */
 			/* waithing 1 system clock cycles
 				then sample the PCMIN singals */
-			(0 << 4) |
-			(0 << 3) |	/* use clock counter to do the sample */
-			/* fs not inverted. H = left, L = right */
-			(0 << 2) |
-			(1 << 1) |	/* msb first */
-			(1 << 0));	/* left justified */
+	       (0 << 4) |
+	       (0 << 3) |	/* use clock counter to do the sample */
+	       (0 << 2) |	/* fs not inverted. H = left, L = right */
+	       (1 << 1) |	/* msb first */
+	       (1 << 0));	/* left justified */
 	}
 
 	pr_debug("PCMIN %s\n", flag ? "enable" : "disable");
@@ -333,14 +329,14 @@ void pcm_in_set_buf(unsigned int addr, unsigned int size)
 
 int pcm_in_is_enable(void)
 {
-	int value = aml_audin_read_bits(PCMIN_CTRL0, 31, 1);
+	int value = aml_read_cbus_bits(PCMIN_CTRL0, 31, 1);
 
 	return value;
 }
 
 unsigned int pcm_in_rd_ptr(void)
 {
-	unsigned int value = aml_audin_read(AUDIN_FIFO1_RDPTR);
+	unsigned int value = aml_read_cbus(AUDIN_FIFO1_RDPTR);
 	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x\n", value);
 
 	return value;
@@ -348,8 +344,8 @@ unsigned int pcm_in_rd_ptr(void)
 
 unsigned int pcm_in_set_rd_ptr(unsigned int value)
 {
-	unsigned int old = aml_audin_read(AUDIN_FIFO1_RDPTR);
-	aml_audin_write(AUDIN_FIFO1_RDPTR, value);
+	unsigned int old = aml_read_cbus(AUDIN_FIFO1_RDPTR);
+	aml_write_cbus(AUDIN_FIFO1_RDPTR, value);
 	pr_debug("PCMIN AUDIN_FIFO1_RDPTR: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
@@ -361,10 +357,10 @@ unsigned int pcm_in_wr_ptr(void)
 	unsigned int written = 0;
 	unsigned int value = 0;
 
-	writing = aml_audin_read(AUDIN_FIFO1_PTR);
+	writing = aml_read_cbus(AUDIN_FIFO1_PTR);
 
-	aml_audin_write(AUDIN_FIFO1_PTR, 1);
-	written = aml_audin_read(AUDIN_FIFO1_PTR);
+	aml_write_cbus(AUDIN_FIFO1_PTR, 1);
+	written = aml_read_cbus(AUDIN_FIFO1_PTR);
 	pr_debug("PCMIN AUDIN_FIFO1_PTR: 0x%08x (0x%08x)\n", written, writing);
 
 	/* value = written; */
@@ -375,7 +371,7 @@ unsigned int pcm_in_wr_ptr(void)
 unsigned int pcm_in_fifo_int(void)
 {
 	unsigned int value = 0;
-	value = aml_audin_read(AUDIN_FIFO_INT);
+	value = aml_read_cbus(AUDIN_FIFO_INT);
 	pr_debug("PCMIN AUDIN_FIFO_INT: 0x%08x\n", value);
 
 	return value;
@@ -385,25 +381,25 @@ static void pcm_out_register_show(void)
 {
 	pr_debug("PCMOUT registers show:\n");
 	pr_debug("\tAUDOUT_BUF0_STA(0x%04x):  0x%08x\n", AUDOUT_BUF0_STA,
-		  aml_audin_read(AUDOUT_BUF0_STA));
+		  aml_read_cbus(AUDOUT_BUF0_STA));
 	pr_debug("\tAUDOUT_BUF0_EDA(0x%04x):  0x%08x\n", AUDOUT_BUF0_EDA,
-		  aml_audin_read(AUDOUT_BUF0_EDA));
+		  aml_read_cbus(AUDOUT_BUF0_EDA));
 	pr_debug("\tAUDOUT_BUF0_WPTR(0x%04x): 0x%08x\n", AUDOUT_BUF0_WPTR,
-		  aml_audin_read(AUDOUT_BUF0_WPTR));
+		  aml_read_cbus(AUDOUT_BUF0_WPTR));
 	pr_debug("\tAUDOUT_FIFO_RPTR(0x%04x): 0x%08x\n", AUDOUT_FIFO_RPTR,
-		  aml_audin_read(AUDOUT_FIFO_RPTR));
+		  aml_read_cbus(AUDOUT_FIFO_RPTR));
 	pr_debug("\tAUDOUT_CTRL(0x%04x):      0x%08x\n", AUDOUT_CTRL,
-		  aml_audin_read(AUDOUT_CTRL));
+		  aml_read_cbus(AUDOUT_CTRL));
 	pr_debug("\tAUDOUT_CTRL1(0x%04x):     0x%08x\n", AUDOUT_CTRL1,
-		  aml_audin_read(AUDOUT_CTRL1));
+		  aml_read_cbus(AUDOUT_CTRL1));
 	pr_debug("\tPCMOUT_CTRL0(0x%04x):     0x%08x\n", PCMOUT_CTRL0,
-		  aml_audin_read(PCMOUT_CTRL0));
+		  aml_read_cbus(PCMOUT_CTRL0));
 	pr_debug("\tPCMOUT_CTRL1(0x%04x):     0x%08x\n", PCMOUT_CTRL1,
-		  aml_audin_read(PCMOUT_CTRL1));
+		  aml_read_cbus(PCMOUT_CTRL1));
 	pr_debug("\tPCMOUT_CTRL2(0x%04x):     0x%08x\n", PCMOUT_CTRL2,
-		  aml_audin_read(PCMOUT_CTRL2));
+		  aml_read_cbus(PCMOUT_CTRL2));
 	pr_debug("\tPCMOUT_CTRL3(0x%04x):     0x%08x\n", PCMOUT_CTRL3,
-		  aml_audin_read(PCMOUT_CTRL3));
+		  aml_read_cbus(PCMOUT_CTRL3));
 }
 
 void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
@@ -444,28 +440,28 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 	}
 
 	/* reset fifo */
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
 	/* disable fifo */
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
 
 	if (!pcm_in_is_enable()) {
 		/* reset pcmout */
-		aml_audin_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
-		aml_audin_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
 		/* disable pcmout */
-		aml_audin_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+		aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
 	}
 
 	if (flag) {
 		/* set buffer start ptr end */
-		aml_audin_write(AUDOUT_BUF0_STA, pcmout_buffer_addr);
-		aml_audin_write(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
-		aml_audin_write(AUDOUT_BUF0_EDA,
+		aml_write_cbus(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_EDA,
 			pcmout_buffer_addr + pcmout_buffer_size - 8);
 
 		/* fifo control */
-		aml_audin_write(AUDOUT_CTRL, (0 << 31) |     /* fifo enable */
+		aml_write_cbus(AUDOUT_CTRL, (0 << 31) |     /* fifo enable */
 			(0 << 30) |     /* soft reset */
 			(1 << 29) |     /* load address */
 			/* use cbus AUDOUT BUFFER0 write pointer
@@ -481,7 +477,7 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 			(6 << 0)        /* endian */
 		);
 
-		aml_audin_write(AUDOUT_CTRL, (1 << 31) |/* fifo enable */
+		aml_write_cbus(AUDOUT_CTRL, (1 << 31) |/* fifo enable */
 			(0 << 30) |     /* soft reset */
 			(1 << 29) |     /* load address */
 			/* use cbus AUDOUT BUFFER0 write pointer
@@ -498,11 +494,11 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 		);
 
 		/* pcmout control3 */
-		aml_audin_write(PCMOUT_CTRL3, 0); /* mute constant */
+		aml_write_cbus(PCMOUT_CTRL3, 0); /* mute constant */
 
 		/* pcmout control2 */
 		/* FS * 16 * 16 = BCLK */
-		aml_audin_write(PCMOUT_CTRL2,
+		aml_write_cbus(PCMOUT_CTRL2,
 			/* underrun use mute constant */
 			(0 << 29) |
 			/* pcmo max slot number in one frame */
@@ -514,7 +510,7 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 		);
 
 		/* pcmout control1 */
-		aml_audin_write(PCMOUT_CTRL1,
+		aml_write_cbus(PCMOUT_CTRL1,
 			/* pcmo output data byte number.  00 : 8bits.
 			01: 16bits. 10: 24bits. 11: 32bits */
 			(pcm_mode << 30) |
@@ -537,7 +533,7 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 		);
 
 		/* pcmout control0 */
-		aml_audin_write(PCMOUT_CTRL0,
+		aml_write_cbus(PCMOUT_CTRL0,
 			(1 << 31) |     /* enable */
 			(1 << 29) |     /* master */
 			(1 << 28) |     /* sync on clock rising edge */
@@ -564,47 +560,45 @@ void pcm_master_out_enable(struct snd_pcm_substream *substream, int flag)
 void pcm_out_enable(int flag)
 {
 	/* reset fifo */
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 30, 1 << 30);
 
 	/* reset pcmout */
-	aml_audin_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
-	aml_audin_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 1 << 30);
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 30, 0 << 30);
 
 	/* disable fifo */
-	aml_audin_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
+	aml_cbus_update_bits(AUDOUT_CTRL, 1 << 31, 0 << 31);
 
 	/* disable pcmout */
-	aml_audin_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
+	aml_cbus_update_bits(PCMOUT_CTRL0, 1 << 31, 0 << 31);
 
 	if (flag) {
 		/* set buffer start ptr end */
-		aml_audin_write(AUDOUT_BUF0_STA, pcmout_buffer_addr);
-		aml_audin_write(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
-		aml_audin_write(AUDOUT_BUF0_EDA,
+		aml_write_cbus(AUDOUT_BUF0_STA, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_WPTR, pcmout_buffer_addr);
+		aml_write_cbus(AUDOUT_BUF0_EDA,
 			       pcmout_buffer_addr + pcmout_buffer_size - 8);
 
 		/* fifo control */
-		aml_audin_write(AUDOUT_CTRL,
-			(0 << 31) |	/* fifo enable */
-			(0 << 30) |	/* soft reset */
-			(1 << 29) |	/* load address */
+		aml_write_cbus(AUDOUT_CTRL, (0 << 31) |	/* fifo enable */
+	       (0 << 30) |	/* soft reset */
+	       (1 << 29) |	/* load address */
 			/* use cbus AUDOUT BUFFER0 write pointer
 				as the AUDOUT FIFO write pointer */
-			(0 << 22) |
-			(52 << 15) |	/* data request size */
-			(64 << 8) |	/* buffer level to keep */
-			(0 << 7) |	/* buffer level control */
-			(1 << 6) |	/* DMA mode */
-			(1 << 5) |	/* circular buffer */
-			(0 << 4) |	/* use register set 0 always */
-			(1 << 3) |	/* urgent request */
-			(6 << 0));	/* endian */
-
-		aml_audin_write(AUDOUT_CTRL,
-			(1 << 31) |	/* fifo enable */
-			(0 << 30) |	/* soft reset */
-			(0 << 29) |	/* load address */
+	       (0 << 22) |
+	       (52 << 15) |	/* data request size */
+	       (64 << 8) |	/* buffer level to keep */
+	       (0 << 7) |	/* buffer level control */
+	       (1 << 6) |	/* DMA mode */
+	       (1 << 5) |	/* circular buffer */
+	       (0 << 4) |	/* use register set 0 always */
+	       (1 << 3) |	/* urgent request */
+	       (6 << 0));	/* endian */
+
+		aml_write_cbus(AUDOUT_CTRL, (1 << 31) |	/* fifo enable */
+	       (0 << 30) |	/* soft reset */
+	       (0 << 29) |	/* load address */
 			/* use cbus AUDOUT BUFFER0 write pointer
 				as the AUDOUT FIFO write pointer */
 			(0 << 22) |
@@ -618,24 +612,24 @@ void pcm_out_enable(int flag)
 			(6 << 0));	/* endian */
 
 		/* pcmout control3 */
-		aml_audin_write(PCMOUT_CTRL3, 0);	/* mute constant */
+		aml_write_cbus(PCMOUT_CTRL3, 0);	/* mute constant */
 
 		/* pcmout control2 */
 		/* 1 channel per frame */
-		aml_audin_write(PCMOUT_CTRL2, (0 << 29) | (0 << 22) |
+		aml_write_cbus(PCMOUT_CTRL2, (0 << 29) | (0 << 22) |
 			       (15 << 16) |	/* 16 bits per slot */
 			       (1 << 0)	/* enable 1 slot */
 		    );
 
 		/* pcmout control1 */
 		/* use posedge of PCM clock to output data */
-		aml_audin_write(PCMOUT_CTRL1, (1 << 30) | (0 << 28) |
+		aml_write_cbus(PCMOUT_CTRL1, (1 << 30) | (0 << 28) |
 			/* use negedge of pcm clock to check the fs */
 			(1 << 27));
 
 		/* pcmout control0 */
 		/* slave */
-		aml_audin_write(PCMOUT_CTRL0, (1 << 31) | (0 << 29) |
+		aml_write_cbus(PCMOUT_CTRL0, (1 << 31) | (0 << 29) |
 			/* sync on clock rising edge */
 			(1 << 28) |
 			/* data sample mode */
@@ -661,7 +655,7 @@ void pcm_out_enable(int flag)
 void pcm_out_mute(int flag)
 {
 	int value = flag ? 1 : 0;
-	aml_audin_update_bits(PCMOUT_CTRL2, 1 << 31, value << 31);
+	aml_cbus_update_bits(PCMOUT_CTRL2, 1 << 31, value << 31);
 }
 
 void pcm_out_set_buf(unsigned int addr, unsigned int size)
@@ -675,21 +669,21 @@ void pcm_out_set_buf(unsigned int addr, unsigned int size)
 
 int pcm_out_is_enable(void)
 {
-	int value = aml_audin_read_bits(PCMOUT_CTRL0, 31, 1);
+	int value = aml_read_cbus_bits(PCMOUT_CTRL0, 31, 1);
 
 	return value;
 }
 
 int pcm_out_is_mute(void)
 {
-	int value = aml_audin_read_bits(PCMOUT_CTRL2, 31, 1);
+	int value = aml_read_cbus_bits(PCMOUT_CTRL2, 31, 1);
 
 	return value;
 }
 
 unsigned int pcm_out_rd_ptr(void)
 {
-	unsigned int value = aml_audin_read(AUDOUT_FIFO_RPTR);
+	unsigned int value = aml_read_cbus(AUDOUT_FIFO_RPTR);
 	pr_debug("PCMOUT read pointer: 0x%08x\n", value);
 
 	return value;
@@ -698,15 +692,15 @@ unsigned int pcm_out_rd_ptr(void)
 unsigned int pcm_out_wr_ptr(void)
 {
 	unsigned int value = 0;
-	value = aml_audin_read(AUDOUT_BUF0_WPTR);
+	value = aml_read_cbus(AUDOUT_BUF0_WPTR);
 	pr_debug("PCMOUT write pointer: 0x%08x\n", value);
 	return value;
 }
 
 unsigned int pcm_out_set_wr_ptr(unsigned int value)
 {
-	unsigned int old = aml_audin_read(AUDOUT_BUF0_WPTR);
-	aml_audin_write(AUDOUT_BUF0_WPTR, value);
+	unsigned int old = aml_read_cbus(AUDOUT_BUF0_WPTR);
+	aml_write_cbus(AUDOUT_BUF0_WPTR, value);
 	pr_debug("PCMOUT write pointer: 0x%08x -> 0x%08x\n", old, value);
 
 	return old;
diff --git a/sound/soc/aml/m8/aml_g9tv.c b/sound/soc/aml/m8/aml_g9tv.c
index 066a8e6..b0587ac 100644
--- a/sound/soc/aml/m8/aml_g9tv.c
+++ b/sound/soc/aml/m8/aml_g9tv.c
@@ -45,7 +45,6 @@
 #include <linux/io.h>
 #include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 
 #include "aml_i2s.h"
 #include "aml_audio_hw.h"
@@ -55,65 +54,59 @@
 
 static int aml_audio_Hardware_resample;
 static int hardware_resample_locked_flag;
-static int Speaker_Channel_Mask = 1;
-static int EQ_DRC_Channel_Mask;
-static int DAC0_Channel_Mask;
-static int DAC1_Channel_Mask;
-static int Spdif_samesource_Channel_Mask;
+unsigned int clk_rate = 0;
 
-
-static unsigned aml_EQ_param_length = 100;
-static unsigned aml_EQ_param[100] = {
+static u32 aml_EQ_param[20][5] = {
 	/*channel 1 param*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef0*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef1*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef2*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef3*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef4*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef5*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef6*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef7*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef8*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef9*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef0*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef1*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef2*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef3*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef4*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef5*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef6*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef7*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef8*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch1_coef9*/
 	/*channel 2 param*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef0*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef1*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef2*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef3*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef4*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef5*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef6*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef7*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef8*/
-	0x800000, 0x00, 0x00, 0x00, 0x00, /*eq_ch1_coef9*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef0*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef1*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef2*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef3*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef4*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef5*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef6*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef7*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef8*/
+	{0x800000, 0x00, 0x00, 0x00, 0x00}, /*eq_ch2_coef9*/
 };
 
-static unsigned aml_DRC_param_length = 6;
-static u32 aml_drc_table[6] = {
-	0x0000111c, 0x00081bfc, 0x00001571,  /*drc_ae, drc_aa, drc_ad*/
-	0x0380111c, 0x03881bfc, 0x03801571,  /*drc_ae_1m, drc_aa_1m, drc_ad_1m*/
+static u32 drc_table[3][2] = {
+	{0x800000, 0x00}, /*drc_ae && drc_ae_1m*/
+	{0x800000, 0x00}, /*drc_aa && drc_aa_1m*/
+	{0x800000, 0x00}, /*drc_ad && drc_ad_1m*/
 };
 
-static u32 aml_drc_tko_table[6] = {
-	0x0,		0x0,	 /*offset0, offset1*/
-	0xcb000000, 0x0,	 /*thd0, thd1*/
-	0xa0000,	0x40000, /*k0, k1*/
+static u32 drc_tko_table[2][3] = {
+	{0x0, 0xbf000000, 0x40000}, /*offset, thd, k*/
+	{0x0, 0x0, 0x40000}, /*offset, thd, k*/
 };
 
 static int DRC0_enable(int enable)
 {
-	if (enable == 1) {
-		aml_eqdrc_write(AED_DRC_THD0, aml_drc_tko_table[2]);
-		aml_eqdrc_write(AED_DRC_K0, aml_drc_tko_table[4]);
-	} else {
-		aml_eqdrc_write(AED_DRC_THD0, 0xbf000000);
-		aml_eqdrc_write(AED_DRC_K0, 0x40000);
+	if ((aml_read_cbus(AED_DRC_EN) & 1) == 1) {
+		if (enable == 1) {
+			aml_write_cbus(AED_DRC_THD0, drc_tko_table[0][1]);
+			aml_write_cbus(AED_DRC_K0, drc_tko_table[0][2]);
+		} else {
+			aml_write_cbus(AED_DRC_THD0, 0xbf000000);
+			aml_write_cbus(AED_DRC_K0, 0x40000);
+		}
 	}
 	return 0;
 }
 
-static const char *const audio_in_source_texts[] = {
-	"LINEIN", "ATV", "HDMI", "SPDIFIN" };
+static const char *const audio_in_source_texts[] = { "LINEIN", "ATV", "HDMI"};
 
 static const struct soc_enum audio_in_source_enum =
 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(audio_in_source_texts),
@@ -133,21 +126,21 @@ static int aml_audio_set_in_source(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	if (ucontrol->value.enumerated.item[0] == 0) {
-		if (is_meson_txl_cpu() || is_meson_txlx_cpu()) {
+		if (is_meson_txl_cpu()) {
 			/* select internal codec ADC in TXL as I2S source */
-			aml_audin_update_bits(AUDIN_SOURCE_SEL, 3, 3);
+			aml_write_cbus(AUDIN_SOURCE_SEL, 3);
 		} else
 			/* select external codec ADC as I2S source */
-			aml_audin_update_bits(AUDIN_SOURCE_SEL, 3, 0);
-		if (is_meson_txl_cpu() || is_meson_txlx_cpu())
+			aml_write_cbus(AUDIN_SOURCE_SEL, 0);
+		audio_in_source = 0;
+		if (is_meson_txl_cpu())
 			DRC0_enable(1);
-		External_Mute(0);
 	} else if (ucontrol->value.enumerated.item[0] == 1) {
 		/* select ATV output as I2S source */
-		aml_audin_update_bits(AUDIN_SOURCE_SEL, 3, 1);
-		if (is_meson_txl_cpu() || is_meson_txlx_cpu())
+		aml_write_cbus(AUDIN_SOURCE_SEL, 1);
+		audio_in_source = 1;
+		if (is_meson_txl_cpu())
 			DRC0_enable(1);
-		External_Mute(0);
 	} else if (ucontrol->value.enumerated.item[0] == 2) {
 		/* select HDMI-rx as Audio In source */
 		/* [14:12]cntl_hdmirx_chsts_sel: */
@@ -157,18 +150,14 @@ static int aml_audio_set_in_source(struct snd_kcontrol *kcontrol,
 		/* 1=Select HDMIRX SPDIF output as AUDIN source */
 		/* [1:0] i2sin_src_sel: */
 		/*2=Select HDMIRX I2S output as AUDIN source */
-		aml_audin_write(AUDIN_SOURCE_SEL, (0 << 12) |
+		aml_write_cbus(AUDIN_SOURCE_SEL, (0 << 12) |
 				   (0xf << 8) | (1 << 4) | (2 << 0));
-		if (is_meson_txl_cpu() || is_meson_txlx_cpu())
+		audio_in_source = 2;
+		if (is_meson_txl_cpu())
 			DRC0_enable(0);
-	}  else if (ucontrol->value.enumerated.item[0] == 3) {
-		aml_audin_update_bits(AUDIN_SOURCE_SEL, 0x3 << 4, 0);
-		if (is_meson_txl_cpu() || is_meson_txlx_cpu())
-			DRC0_enable(0);
-		External_Mute(0);
 	}
 
-	audio_in_source = ucontrol->value.enumerated.item[0];
+	set_i2s_source(audio_in_source);
 	return 0;
 }
 
@@ -186,8 +175,8 @@ static int aml_i2s_audio_type_get_enum(
 {
 	int ch_status = 0;
 
-	if ((aml_audin_read(AUDIN_DECODE_CONTROL_STATUS) >> 24) & 0x1) {
-		ch_status = aml_audin_read(AUDIN_DECODE_CHANNEL_STATUS_A_0);
+	if ((aml_read_cbus(AUDIN_DECODE_CONTROL_STATUS) >> 24) & 0x1) {
+		ch_status = aml_read_cbus(AUDIN_DECODE_CHANNEL_STATUS_A_0);
 		if (ch_status & 2)
 			ucontrol->value.enumerated.item[0] = 1;
 		else
@@ -236,7 +225,7 @@ static int aml_spdif_audio_type_get_enum(
 	int audio_type = 0;
 	int i;
 	int total_num = sizeof(type_texts)/sizeof(struct sppdif_audio_info);
-	int pc = aml_audin_read(AUDIN_SPDIF_NPCM_PCPD)>>16;
+	int pc = aml_read_cbus(AUDIN_SPDIF_NPCM_PCPD)>>16;
 	pc = pc&0xff;
 	for (i = 0; i < total_num; i++) {
 		if (pc == type_texts[i].pc) {
@@ -246,20 +235,22 @@ static int aml_spdif_audio_type_get_enum(
 	}
 	ucontrol->value.enumerated.item[0] = audio_type;
 	if (last_audio_type != audio_type) {
-		if (audio_type == 0 || audio_in_source == 3) {
+		if (audio_type == 0) {
 			/*In LPCM, use old spdif mode*/
-			aml_audin_update_bits(AUDIN_FIFO1_CTRL,
+			aml_cbus_update_bits(AUDIN_FIFO1_CTRL,
 				(0x7 << AUDIN_FIFO1_DIN_SEL),
 				(SPDIF_IN << AUDIN_FIFO1_DIN_SEL));
 			/*spdif-in data fromat:(27:4)*/
-			aml_audin_write(AUDIN_FIFO1_CTRL1, 0x88);
+			aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x88);
+			hardware_resample_locked_flag = 0;
 		} else {
 			/*In RAW data, use PAO mode*/
-			aml_audin_update_bits(AUDIN_FIFO1_CTRL,
+			aml_cbus_update_bits(AUDIN_FIFO1_CTRL,
 				(0x7 << AUDIN_FIFO1_DIN_SEL),
 				(PAO_IN << AUDIN_FIFO1_DIN_SEL));
 			/*spdif-in data fromat:(23:0)*/
-			aml_audin_write(AUDIN_FIFO1_CTRL1, 0x8);
+			aml_write_cbus(AUDIN_FIFO1_CTRL1, 0x8);
+			hardware_resample_locked_flag = 1;
 		}
 		last_audio_type = audio_type;
 	}
@@ -296,9 +287,9 @@ static int hardware_resample_enable(int input_sr)
 	pr_info("clk_rate = %u, input_sr = %d, Avg_cnt_init = %u\n",
 		clk_rate, input_sr, Avg_cnt_init);
 
-	aml_audin_write(AUD_RESAMPLE_CTRL0, (1 << 31));
-	aml_audin_write(AUD_RESAMPLE_CTRL0, 0);
-	aml_audin_write(AUD_RESAMPLE_CTRL0,
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, (1 << 31));
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
+	aml_write_cbus(AUD_RESAMPLE_CTRL0,
 				(1 << 29)
 				| (1 << 28)
 				| (0 << 26)
@@ -310,7 +301,7 @@ static int hardware_resample_enable(int input_sr)
 
 static int hardware_resample_disable(void)
 {
-	aml_audin_write(AUD_RESAMPLE_CTRL0, 0);
+	aml_write_cbus(AUD_RESAMPLE_CTRL0, 0);
 	return 0;
 }
 
@@ -407,26 +398,49 @@ static int aml_set_audio_in_switch(struct snd_kcontrol *kcontrol,
 
 static int init_EQ_DRC_module(void)
 {
-	aml_eqdrc_write(AED_TOP_CTL, (1 << 31)); /* fifo init */
-	aml_eqdrc_write(AED_ED_CTL, 1); /* soft reset*/
+	aml_write_cbus(AED_TOP_CTL, (1 << 31)); /* fifo init */
+	aml_write_cbus(AED_ED_CTL, 1); /* soft reset*/
 	msleep(20);
-	aml_eqdrc_write(AED_ED_CTL, 0); /* soft reset*/
-	aml_eqdrc_write(AED_TOP_CTL, (0 << 1) /*i2s in sel*/
+	aml_write_cbus(AED_ED_CTL, 0); /* soft reset*/
+	aml_write_cbus(AED_TOP_CTL, (0 << 1) /*i2s in sel*/
 						| (1 << 0)); /*module enable*/
-	aml_eqdrc_write(AED_NG_CTL, (3 << 30)); /* disable noise gate*/
+	aml_write_cbus(AED_NG_CTL, (3 << 30)); /* disable noise gate*/
 	return 0;
 }
 
 static int set_internal_EQ_volume(unsigned master_volume,
 			unsigned channel_1_volume, unsigned channel_2_volume)
 {
-	aml_eqdrc_write(AED_EQ_VOLUME, (2 << 30) /* volume step: 0.5dB*/
+	aml_write_cbus(AED_EQ_VOLUME, (2 << 30) /* volume step: 0.5dB*/
 			| (master_volume << 16) /* master volume: 0dB*/
 			| (channel_1_volume << 8) /* channel 1 volume: 0dB*/
 			| (channel_2_volume << 0) /* channel 2 volume: 0dB*/
 			);
-	aml_eqdrc_write(AED_EQ_VOLUME_SLEW_CNT, 0x40);
-	aml_eqdrc_write(AED_MUTE, 0);
+	aml_write_cbus(AED_EQ_VOLUME_SLEW_CNT, 0x40);
+	aml_write_cbus(AED_MUTE, 0);
+	return 0;
+}
+
+static int Speaker_Channel_Mask;
+static const char *const Speaker_Channel_Mask_texts[] = {
+	"Channel0/1", "Channel2/3", "Channe4/5", "Channe6/7" };
+
+static const struct soc_enum Speaker_Channel_Mask_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0,
+			ARRAY_SIZE(Speaker_Channel_Mask_texts),
+			Speaker_Channel_Mask_texts);
+
+static int aml_Speaker_Channel_Mask_get_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = Speaker_Channel_Mask;
+	return 0;
+}
+
+static int aml_Speaker_Channel_Mask_set_enum(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	Speaker_Channel_Mask = ucontrol->value.enumerated.item[0];
 	return 0;
 }
 
@@ -458,60 +472,22 @@ static const struct snd_kcontrol_new aml_g9tv_controls[] = {
 		     aml_hardware_resample_get_enum,
 		     aml_hardware_resample_set_enum),
 
+	SOC_ENUM_EXT("Speaker Channel Mask",
+		     Speaker_Channel_Mask_enum,
+		     aml_Speaker_Channel_Mask_get_enum,
+		     aml_Speaker_Channel_Mask_set_enum),
 };
 
-static int aml_get_eqdrc_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol) {
-
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int max = mc->max;
-	unsigned int invert = mc->invert;
-	unsigned int value =
-			(((unsigned)aml_eqdrc_read(reg)) >> shift) & max;
-
-	if (invert)
-		value = (~value) & max;
-	ucontrol->value.integer.value[0] = value;
-
-	return 0;
-}
-
-static int aml_set_eqdrc_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol) {
-
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int max = mc->max;
-	unsigned int invert = mc->invert;
-	unsigned int value = ucontrol->value.integer.value[0];
-	unsigned int reg_value = (unsigned int)aml_eqdrc_read(reg);
-
-	if (invert)
-		value = (~value) & max;
-	max = ~(max << shift);
-	reg_value &= max;
-	reg_value |= (value << shift);
-	aml_eqdrc_write(reg, reg_value);
-
-	return 0;
-}
-
-#if 0
 static int set_HW_resample_pause_thd(unsigned int thd)
 {
-	aml_audin_write(AUD_RESAMPLE_CTRL2,
+	aml_write_cbus(AUD_RESAMPLE_CTRL2,
 			(1 << 24) /* enable HW_resample_pause*/
 			| (thd << 11) /* set HW resample pause thd (sample)*/
 			);
 	return 0;
 }
 
-static int aml_get_audin_reg(struct snd_kcontrol *kcontrol,
+static int aml_get_cbus_reg(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol) {
 
 	struct soc_mixer_control *mc =
@@ -521,7 +497,7 @@ static int aml_get_audin_reg(struct snd_kcontrol *kcontrol,
 	unsigned int max = mc->max;
 	unsigned int invert = mc->invert;
 	unsigned int value =
-			(((unsigned)aml_audin_read(reg)) >> shift) & max;
+			(((unsigned)aml_read_cbus(reg)) >> shift) & max;
 
 	if (invert)
 		value = (~value) & max;
@@ -530,7 +506,7 @@ static int aml_get_audin_reg(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static int aml_set_audin_reg(struct snd_kcontrol *kcontrol,
+static int aml_set_cbus_reg(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol) {
 
 	struct soc_mixer_control *mc =
@@ -540,61 +516,17 @@ static int aml_set_audin_reg(struct snd_kcontrol *kcontrol,
 	unsigned int max = mc->max;
 	unsigned int invert = mc->invert;
 	unsigned int value = ucontrol->value.integer.value[0];
-	unsigned int reg_value = (unsigned int)aml_audin_read(reg);
+	unsigned int reg_value = (unsigned int)aml_read_cbus(reg);
 
 	if (invert)
 		value = (~value) & max;
 	max = ~(max << shift);
 	reg_value &= max;
 	reg_value |= (value << shift);
-	aml_audin_write(reg, reg_value);
+	aml_write_cbus(reg, reg_value);
 
 	return 0;
 }
-#endif
-
-static int set_aml_EQ_param(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int value = ucontrol->value.integer.value[0];
-	int i = 0;
-	u32 *reg_ptr = &aml_EQ_param[0];
-
-	if (value == 1) {
-		for (i = 0; i < 100; i++) {
-			aml_eqdrc_write(AED_EQ_CH1_COEF00 + i, *reg_ptr);
-			/*pr_info("EQ value[%d]: 0x%x\n", i, *reg_ptr);*/
-			reg_ptr++;
-		}
-	}
-	aml_eqdrc_update_bits(AED_EQ_EN, 1, value);
-	return 0;
-}
-
-static int set_aml_DRC_param(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int value = ucontrol->value.integer.value[0];
-	int i = 0;
-	u32 *reg_ptr = &aml_drc_table[0];
-
-	if (value == 1) {
-		for (i = 0; i < 6; i++) {
-			aml_eqdrc_write(AED_DRC_AE + i, *reg_ptr);
-			/*pr_info("DRC table value[%d]: 0x%x\n", i, *reg_ptr);*/
-			reg_ptr++;
-		}
-
-		reg_ptr = &aml_drc_tko_table[0];
-		for (i = 0; i < 6; i++) {
-			aml_eqdrc_write(AED_DRC_OFFSET0 + i, *reg_ptr);
-			/*pr_info("DRC tko value[%d]: 0x%x\n", i, *reg_ptr);*/
-			reg_ptr++;
-		}
-	}
-	aml_eqdrc_update_bits(AED_DRC_EN, 1, value);
-	return 0;
-}
 
 static const DECLARE_TLV_DB_SCALE(mvol_tlv, -12276, 12, 1);
 static const DECLARE_TLV_DB_SCALE(chvol_tlv, -12750, 50, 1);
@@ -602,64 +534,63 @@ static const DECLARE_TLV_DB_SCALE(chvol_tlv, -12750, 50, 1);
 static const struct snd_kcontrol_new aml_EQ_DRC_controls[] = {
 	SOC_SINGLE_EXT_TLV("EQ master volume",
 			 AED_EQ_VOLUME, 16, 0x3FF, 1,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 mvol_tlv),
 
 	SOC_SINGLE_EXT_TLV("EQ ch1 volume",
 			 AED_EQ_VOLUME, 8, 0xFF, 1,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 chvol_tlv),
 
 	SOC_SINGLE_EXT_TLV("EQ ch2 volume",
 			 AED_EQ_VOLUME, 0, 0xFF, 1,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 chvol_tlv),
 
 	SOC_SINGLE_EXT_TLV("EQ master volume mute",
 			 AED_MUTE, 31, 0x1, 0,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("EQ enable",
 			 AED_EQ_EN, 0, 0x1, 0,
-			 aml_get_eqdrc_reg, set_aml_EQ_param,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("DRC enable",
 			 AED_DRC_EN, 0, 0x1, 0,
-			 aml_get_eqdrc_reg, set_aml_DRC_param,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("NG enable",
 			 AED_NG_CTL, 0, 0x1, 0,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("NG noise thd",
 			 AED_NG_THD0, 8, 0x7FFF, 0,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("NG signal thd",
 			 AED_NG_THD1, 8, 0x7FFF, 0,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("NG counter thd",
 			 AED_NG_CNT_THD, 0, 0xFFFF, 0,
-			 aml_get_eqdrc_reg, aml_set_eqdrc_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
-	/*
+
 	SOC_SINGLE_EXT_TLV("Hw resample pause enable",
 			 AUD_RESAMPLE_CTRL2, 24, 0x1, 0,
-			 aml_get_audin_reg, aml_set_audin_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
 
 	SOC_SINGLE_EXT_TLV("Hw resample pause thd",
 			 AUD_RESAMPLE_CTRL2, 11, 0x1FFF, 0,
-			 aml_get_audin_reg, aml_set_audin_reg,
+			 aml_get_cbus_reg, aml_set_cbus_reg,
 			 NULL),
-	*/
 };
 
 static void aml_audio_start_timer(struct aml_audio_private_data *p_aml_audio,
@@ -891,7 +822,7 @@ static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
 	int ret;
 
 	/* set cpu DAI configuration */
-	if (is_meson_txl_cpu() || is_meson_txlx_cpu())
+	if (is_meson_txl_cpu())
 		ret = snd_soc_dai_set_fmt(cpu_dai,
 				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
 				  | SND_SOC_DAIFMT_CBM_CFM);
@@ -1028,96 +959,6 @@ static void aml_g9tv_pinmux_init(struct snd_soc_card *card)
 	return;
 }
 
-static int check_channel_mask(const char *str)
-{
-	int ret = -1;
-	if (!strncmp(str, "i2s_0/1", 7))
-		ret = 0;
-	else if (!strncmp(str, "i2s_2/3", 7))
-		ret = 1;
-	else if (!strncmp(str, "i2s_4/5", 7))
-		ret = 2;
-	else if (!strncmp(str, "i2s_6/7", 7))
-		ret = 3;
-	return ret;
-}
-
-static void channel_mask_parse(struct snd_soc_card *card)
-{
-	struct device_node *audio_codec_node = card->dev->of_node;
-	struct device_node *child;
-	const char *str;
-	int ret;
-	child = of_get_child_by_name(audio_codec_node, "Channel_Mask");
-	if (child == NULL) {
-		pr_info("error: failed to find channel mask node %s\n",
-				"Channel_Mask");
-		return;
-	}
-
-	if (is_meson_txl_cpu() || is_meson_txlx_cpu()) {
-		/*Speaker need Audio Effcet from user space by i2s2/3,
-		mux i2s2/3 to layout pin*/
-		of_property_read_string(child, "Speaker_Channel_Mask", &str);
-		ret = check_channel_mask(str);
-		if (ret >= 0) {
-			Speaker_Channel_Mask = ret;
-			aml_aiu_update_bits(AIU_I2S_OUT_CFG,
-					0x3 << (Speaker_Channel_Mask * 2),
-					1 << (Speaker_Channel_Mask * 2));
-			if (Speaker_Channel_Mask == 0) {
-				aml_aiu_update_bits(AIU_I2S_OUT_CFG,
-					0x3 << 2, 0 << 2);
-			}
-		}
-	}
-
-	if (is_meson_txlx_cpu()) {
-		/*Acodec DAC0 selects i2s source*/
-		of_property_read_string(child, "DAC0_Channel_Mask", &str);
-		ret = check_channel_mask(str);
-		if (ret >= 0) {
-			DAC0_Channel_Mask = ret;
-			aml_aiu_update_bits(AIU_ACODEC_CTRL, 0x3,
-					DAC0_Channel_Mask);
-		}
-		/*Acodec DAC1 selects i2s source*/
-		of_property_read_string(child, "DAC1_Channel_Mask", &str);
-		ret = check_channel_mask(str);
-		if (ret >= 0) {
-			DAC1_Channel_Mask = ret;
-			aml_aiu_update_bits(AIU_ACODEC_CTRL, 0x3 << 8,
-					DAC1_Channel_Mask << 8);
-		}
-
-		/*Hardware EQ and DRC can be muxed to i2s 2 channels*/
-		of_property_read_string(child, "EQ_DRC_Channel_Mask", &str);
-		ret = check_channel_mask(str);
-		if (ret >= 0) {
-			EQ_DRC_Channel_Mask = ret;
-			 /*i2s in sel*/
-			aml_eqdrc_update_bits(AED_TOP_CTL, (0x7 << 1),
-				(EQ_DRC_Channel_Mask << 1));
-			aml_eqdrc_write(AED_ED_CTL, 1);
-			/* disable noise gate*/
-			aml_eqdrc_write(AED_NG_CTL, (3 << 30));
-			aml_eqdrc_update_bits(AED_TOP_CTL, 1, 1);
-		}
-
-		/*If spdif is same source to i2s,
-		it can be muxed to i2s 2 channels*/
-		of_property_read_string(child,
-				"Spdif_samesource_Channel_Mask", &str);
-		ret = check_channel_mask(str);
-		if (ret >= 0) {
-			Spdif_samesource_Channel_Mask = ret;
-			aml_aiu_update_bits(AIU_I2S_MISC, 0x7 << 5,
-					Spdif_samesource_Channel_Mask << 5);
-		}
-	}
-	return;
-}
-
 static int aml_card_dai_parse_of(struct device *dev,
 				 struct snd_soc_dai_link *dai_link,
 				 int (*init)(
@@ -1155,6 +996,7 @@ static struct snd_soc_codec_conf g9tv_audio_codec_conf[] = {
 		.name_prefix = "AMP",
 	},
 };
+static struct codec_probe_priv prob_priv;
 static struct codec_info codec_info_aux;
 
 static int get_audio_codec_i2c_info(struct device_node *p_node,
@@ -1209,6 +1051,192 @@ err_out:
 	return ret;
 }
 
+static char drc1_table[15] = "drc1_table_0";
+static char drc1_tko_table[20] = "drc1_tko_table_0";
+static char drc2_table[15] = "drc2_table_0";
+static char drc2_tko_table[20] = "drc2_tko_table_0";
+static int aml_drc_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(drc1_table, "%s%s", "drc1_table_", sel);
+		sprintf(drc1_tko_table, "%s%s", "drc1_tko_table_", sel);
+		sprintf(drc2_table, "%s%s", "drc2_table_", sel);
+		sprintf(drc2_tko_table, "%s%s", "drc2_tko_table_", sel);
+		pr_info("select drc type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_drc_type=", aml_drc_type_select);
+
+static char table[10] = "table_0";
+static char wall[10] = "wall_0";
+static char sub_bq_table[20] = "sub_bq_table_0";
+static int aml_eq_type_select(char *s)
+{
+	char *sel = s;
+
+	if (NULL != s) {
+		sprintf(table, "%s%s", "table_", sel);
+		sprintf(wall, "%s%s", "wall_", sel);
+		sprintf(sub_bq_table, "%s%s", "sub_bq_table_", sel);
+		pr_info("select eq type: %s\n", sel);
+	}
+	return 0;
+}
+__setup("amp_eq_type=", aml_eq_type_select);
+
+static void *alloc_and_get_data_array(struct device_node *p_node, char *str,
+				      int *lenp)
+{
+	int ret = 0, length = 0;
+	char *p = NULL;
+
+	if (of_find_property(p_node, str, &length) == NULL) {
+		pr_err("DTD of %s not found!\n", str);
+		goto exit;
+	}
+	pr_debug("prop name=%s,length=%d\n", str, length);
+	p = kzalloc(length * sizeof(char *), GFP_KERNEL);
+	if (p == NULL) {
+		pr_err("ERROR, NO enough mem for %s!\n", str);
+		length = 0;
+		goto exit;
+	}
+
+	ret = of_property_read_u8_array(p_node, str, p, length);
+	if (ret) {
+		pr_err("no of property %s!\n", str);
+		kfree(p);
+		p = NULL;
+		goto exit;
+	}
+
+	*lenp = length;
+
+exit: return p;
+}
+
+static int of_get_eq_pdata(struct tas57xx_platform_data *pdata,
+			   struct device_node *p_node)
+{
+	int length = 0;
+	char *regs = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "eq_enable", &pdata->eq_enable);
+	if (pdata->eq_enable == 0 || ret != 0) {
+		pr_err("Fail to get eq_enable node or EQ disable!\n");
+		return -2;
+	}
+
+	prob_priv.num_eq = 2;
+	pdata->num_eq_cfgs = prob_priv.num_eq;
+
+	prob_priv.eq_configs = kzalloc(
+		prob_priv.num_eq * sizeof(struct tas57xx_eq_cfg), GFP_KERNEL);
+
+	regs = alloc_and_get_data_array(p_node, table, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[0].name, table, NAME_SIZE);
+	prob_priv.eq_configs[0].regs = regs;
+	prob_priv.eq_configs[0].reg_bytes = length;
+
+	regs = alloc_and_get_data_array(p_node, wall, &length);
+	if (regs == NULL) {
+		kfree(prob_priv.eq_configs);
+		return -2;
+	}
+	strncpy(prob_priv.eq_configs[1].name, wall, NAME_SIZE);
+	prob_priv.eq_configs[1].regs = regs;
+	prob_priv.eq_configs[1].reg_bytes = length;
+
+	pdata->eq_cfgs = prob_priv.eq_configs;
+	return 0;
+}
+
+static int of_get_drc_pdata(struct tas57xx_platform_data *pdata,
+			    struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+	int ret = 0;
+
+	ret = of_property_read_u32(p_node, "drc_enable", &pdata->drc_enable);
+	if (pdata->drc_enable == 0 || ret != 0) {
+		pr_err("Fail to get drc_enable node or DRC disable!\n");
+		return -2;
+	}
+
+	/* get drc1 table */
+	pd = alloc_and_get_data_array(p_node, drc1_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_table_len = length;
+	pdata->custom_drc1_table = pd;
+
+	/* get drc1 tko table */
+	length = 0;
+	pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, drc1_tko_table, &length);
+	if (pd == NULL)
+		return -2;
+	pdata->custom_drc1_tko_table_len = length;
+	pdata->custom_drc1_tko_table = pd;
+	pdata->enable_ch1_drc = 1;
+
+	/* get drc2 table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_table_len = length;
+	pdata->custom_drc2_table = pd;
+
+	/* get drc2 tko table */
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, drc2_tko_table, &length);
+	if (pd == NULL)
+		return -1;
+	pdata->custom_drc2_tko_table_len = length;
+	pdata->custom_drc2_tko_table = pd;
+	pdata->enable_ch2_drc = 1;
+
+	return 0;
+}
+
+static int of_get_init_pdata(struct tas57xx_platform_data *pdata,
+			     struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "input_mux_reg_buf", &length);
+	if (pd == NULL) {
+		pr_err("%s : can't get input_mux_reg_buf\n", __func__);
+		return -1;
+	}
+
+	/*Now only support 0x20 input mux init*/
+	pdata->num_init_regs = length;
+	pdata->init_regs = pd;
+
+	if (of_property_read_u32(p_node, "master_vol",
+				 &pdata->custom_master_vol)) {
+		pr_err("%s fail to get master volume\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
 static int of_get_resetpin_pdata(struct tas57xx_platform_data *pdata,
 				 struct device_node *p_node)
 {
@@ -1245,7 +1273,6 @@ static int of_get_phonepin_pdata(struct tas57xx_platform_data *pdata,
 	}
 	return 0;
 }
-
 static int of_get_scanpin_pdata(struct tas57xx_platform_data *pdata,
 				 struct device_node *p_node)
 {
@@ -1273,7 +1300,6 @@ static int codec_get_of_pdata(struct tas57xx_platform_data *pdata,
 	if (ret)
 		pr_info("codec reset pin is not found in dts\n");
 	ret = of_get_phonepin_pdata(pdata, p_node);
-
 	if (ret)
 		pr_info("codec phone pin is not found in dtd\n");
 
@@ -1281,6 +1307,17 @@ static int codec_get_of_pdata(struct tas57xx_platform_data *pdata,
 	if (ret)
 		pr_info("codec scanp pin is not found in dtd\n");
 
+	ret = of_get_drc_pdata(pdata, p_node);
+	if (ret == -2)
+		pr_info("codec DRC configs are not found in dts\n");
+
+	ret = of_get_eq_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec EQ configs are not found in dts\n");
+
+	ret = of_get_init_pdata(pdata, p_node);
+	if (ret)
+		pr_info("codec init configs are not found in dts\n");
 	return ret;
 }
 
@@ -1340,10 +1377,10 @@ static int aml_aux_dev_parse_of(struct snd_soc_card *card)
 		}
 		codec_get_of_pdata(pdata, child);
 		client->dev.platform_data = pdata;
+		Speaker_Channel_Mask = 1;
 	}
 	return 0;
 }
-
 static int aml_card_dais_parse_of(struct snd_soc_card *card)
 {
 	struct device_node *np = card->dev->of_node;
@@ -1433,6 +1470,120 @@ err:
 	return ret;
 }
 
+static int aml_EQ_DRC_parse_of(struct snd_soc_card *card)
+{
+	struct device_node *audio_codec_node = card->dev->of_node;
+	struct device_node *child;
+	struct aml_audio_private_data *p_aml_audio;
+	int length = 0;
+	int ret = 0;
+	int i = 0;
+	u32 *reg_ptr = &aml_EQ_param[0][0];
+
+	p_aml_audio = snd_soc_card_get_drvdata(card);
+
+	child = of_get_child_by_name(audio_codec_node, "aml_EQ_DRC");
+	if (child == NULL) {
+		pr_err("Error: failed to find node %s\n", "aml_EQ_DRC");
+		return -1;
+	}
+
+	if (of_find_property(child, "eq_table", &length) == NULL) {
+		pr_err("[%s] node not found!\n", "eq_table");
+	} else {
+		of_property_read_u32(child, "EQ_enable",
+				&p_aml_audio->aml_EQ_enable);
+		/*read EQ value from dts*/
+		if (p_aml_audio->aml_EQ_enable) {
+			ret = of_property_read_u32_array(child, "eq_table",
+					reg_ptr, 100);
+			if (ret) {
+				pr_err("Can't get EQ param [%s]!\n",
+					"eq_table");
+			} else {
+				for (i = 0; i < 100; i++) {
+					aml_write_cbus(AED_EQ_CH1_COEF00 + i,
+						*reg_ptr);
+					/*pr_info("EQ value[%d]: 0x%x\n",
+						i, *reg_ptr);*/
+					reg_ptr++;
+				}
+				/*enable aml EQ*/
+				aml_cbus_update_bits(AED_EQ_EN, 0x1, 0x1);
+				pr_info("aml EQ enable!\n");
+			}
+		}
+	}
+
+	if (of_find_property(child, "drc_table", &length) == NULL ||
+			of_find_property(child, "drc_tko_table", &length)
+			== NULL) {
+		pr_err("[%s or %s] not found!\n", "drc_table", "drc_tko_table");
+	} else {
+		/*read DRC value from dts*/
+		of_property_read_u32(child, "DRC_enable",
+			&p_aml_audio->aml_DRC_enable);
+		if (p_aml_audio->aml_DRC_enable) {
+			reg_ptr = &drc_table[0][0];
+			ret = of_property_read_u32_array(child, "drc_table",
+					reg_ptr, 6);
+			if (ret) {
+				pr_err("Can't get drc param [%s]!\n",
+					"drc_table");
+			} else {
+				aml_write_cbus(AED_DRC_AE,
+					drc_table[0][0]);
+				aml_write_cbus(AED_DRC_AA,
+					drc_table[1][0]);
+				aml_write_cbus(AED_DRC_AD,
+					drc_table[2][0]);
+				aml_write_cbus(AED_DRC_AE_1M,
+					drc_table[0][1]);
+				aml_write_cbus(AED_DRC_AA_1M,
+					drc_table[1][1]);
+				aml_write_cbus(AED_DRC_AD_1M,
+					drc_table[2][1]);
+				/*pr_info("DRC table: 0x%x, 0x%x,"
+				"0x%x, 0x%x, 0x%x, 0x%x,\n",
+				drc_table[0][0], drc_table[0][1],
+				drc_table[1][0], drc_table[1][1],
+				drc_table[2][0], drc_table[2][1]);*/
+			}
+
+			reg_ptr = &drc_tko_table[0][0];
+			ret = of_property_read_u32_array(child, "drc_tko_table",
+						reg_ptr, 6);
+			if (ret) {
+				pr_err("Can't get drc param [%s]!\n",
+					"drc_tko_table");
+			} else {
+				aml_write_cbus(AED_DRC_OFFSET0,
+					drc_tko_table[0][0]);
+				aml_write_cbus(AED_DRC_OFFSET1,
+					drc_tko_table[1][0]);
+				aml_write_cbus(AED_DRC_THD0,
+					drc_tko_table[0][1]);
+				aml_write_cbus(AED_DRC_THD1,
+					drc_tko_table[1][1]);
+				aml_write_cbus(AED_DRC_K0,
+					drc_tko_table[0][2]);
+				aml_write_cbus(AED_DRC_K1,
+					drc_tko_table[1][2]);
+				/*pr_info("DRC tko: 0x%x, 0x%x,"
+				"0x%x, 0x%x, 0x%x, 0x%x,\n",
+				drc_tko_table[0][0], drc_tko_table[1][0],
+				drc_tko_table[0][1], drc_tko_table[1][1],
+				drc_tko_table[0][2], drc_tko_table[1][2]);*/
+
+				/*enable aml DRC*/
+				aml_cbus_update_bits(AED_DRC_EN, 0x1, 0x1);
+				pr_info("aml DRC enable!\n");
+			}
+		}
+	}
+	return 0;
+}
+
 static void aml_pinmux_work_func(struct work_struct *pinmux_work)
 {
 	struct aml_audio_private_data *p_aml_audio = NULL;
@@ -1441,17 +1592,6 @@ static void aml_pinmux_work_func(struct work_struct *pinmux_work)
 				  struct aml_audio_private_data, pinmux_work);
 	card = (struct snd_soc_card *)p_aml_audio->data;
 
-	if (is_meson_txl_cpu()) {
-		set_internal_EQ_volume(0xc0, 0x30, 0x30);
-		init_EQ_DRC_module();
-		/*set_HW_resample_pause_thd(128);*/
-	}
-
-	channel_mask_parse(card);
-
-	snd_soc_add_card_controls(card, aml_EQ_DRC_controls,
-					ARRAY_SIZE(aml_EQ_DRC_controls));
-
 	aml_g9tv_pinmux_init(card);
 	return;
 }
@@ -1507,6 +1647,15 @@ static int aml_g9tv_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (is_meson_txl_cpu()) {
+		set_internal_EQ_volume(0xc0, 0x30, 0x30);
+		init_EQ_DRC_module();
+		snd_soc_add_card_controls(card, aml_EQ_DRC_controls,
+					ARRAY_SIZE(aml_EQ_DRC_controls));
+		aml_EQ_DRC_parse_of(card);
+		set_HW_resample_pause_thd(128);
+	}
+
 	p_aml_audio->data = (void *)card;
 	INIT_WORK(&p_aml_audio->pinmux_work, aml_pinmux_work_func);
 	schedule_work(&p_aml_audio->pinmux_work);
@@ -1543,15 +1692,6 @@ static struct platform_driver aml_g9tv_audio_driver = {
 	.shutdown		= aml_g9tv_audio_shutdown,
 };
 
-module_param_array(aml_EQ_param, uint, &aml_EQ_param_length, 0664);
-MODULE_PARM_DESC(aml_EQ_param, "An array of aml EQ param");
-
-module_param_array(aml_drc_table, uint, &aml_DRC_param_length, 0664);
-MODULE_PARM_DESC(aml_drc_table, "An array of aml DRC table param");
-
-module_param_array(aml_drc_tko_table, uint, &aml_DRC_param_length, 0664);
-MODULE_PARM_DESC(aml_drc_tko_table, "An array of aml DRC tko table param");
-
 module_platform_driver(aml_g9tv_audio_driver);
 
 MODULE_AUTHOR("AMLogic, Inc.");
diff --git a/sound/soc/aml/m8/aml_g9tv.h b/sound/soc/aml/m8/aml_g9tv.h
index 64489dc..b78fab0 100644
--- a/sound/soc/aml/m8/aml_g9tv.h
+++ b/sound/soc/aml/m8/aml_g9tv.h
@@ -76,11 +76,8 @@ struct codec_probe_priv {
 	struct tas57xx_eq_cfg *eq_configs;
 };
 
-static int aml_get_eqdrc_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol);
-static int aml_set_eqdrc_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol);
-
-extern int External_Mute(int mute_flag);
+extern struct device *spdif_dev;
+extern void aml_spdif_pinmux_init(struct device *pdev);
+extern void aml_spdif_pinmux_deinit(struct device *pdev);
 
 #endif
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index d5120a2..3d868e7 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -43,7 +43,6 @@
 #include "aml_spdif_dai.h"
 #include "aml_audio_hw.h"
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 
 #define USE_HW_TIMER
 #ifdef USE_HW_TIMER
@@ -64,9 +63,6 @@ EXPORT_SYMBOL(aml_i2s_alsa_write_addr);
 unsigned int aml_i2s_playback_channel = 2;
 EXPORT_SYMBOL(aml_i2s_playback_channel);
 
-unsigned int aml_i2s_playback_format = 16;
-EXPORT_SYMBOL(aml_i2s_playback_format);
-
 static int trigger_underrun;
 void aml_audio_hw_trigger(void)
 {
@@ -120,10 +116,10 @@ static const struct snd_pcm_hardware aml_i2s_capture = {
 	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
 	.period_bytes_min = 64,
-	.period_bytes_max = 32 * 1024 * 2,
+	.period_bytes_max = 32 * 1024,
 	.periods_min = 2,
 	.periods_max = 1024,
-	.buffer_bytes_max = 64 * 1024 * 4,
+	.buffer_bytes_max = 64 * 1024,
 
 	.rate_min = 8000,
 	.rate_max = 48000,
@@ -300,15 +296,8 @@ static int aml_i2s_prepare(struct snd_pcm_substream *substream)
 		dev_info(substream->pcm->card->dev, "clear i2s out trigger underrun\n");
 		trigger_underrun = 0;
 	}
-	if (s && s->device_type == AML_AUDIO_I2SOUT) {
+	if (s && s->device_type == AML_AUDIO_I2SOUT)
 		aml_i2s_playback_channel = runtime->channels;
-		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE)
-			aml_i2s_playback_format = 16;
-		else if (runtime->format == SNDRV_PCM_FORMAT_S32_LE)
-			aml_i2s_playback_format = 32;
-		else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
-			aml_i2s_playback_format = 24;
-	}
 	tmp_buf->cached_len = 0;
 	return 0;
 }
@@ -333,11 +322,11 @@ static int snd_request_hw_timer(void *data)
 {
 	int ret = 0;
 	if (hw_timer_init == 0) {
-		aml_isa_write(ISA_TIMERD, TIMER_COUNT);
-		aml_isa_update_bits(ISA_TIMER_MUX, 3 << 6,
+		aml_write_cbus(ISA_TIMERD, TIMER_COUNT);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 3 << 6,
 					TIMERD_RESOLUTION << 6);
-		aml_isa_update_bits(ISA_TIMER_MUX, 1 << 15, TIMERD_MODE << 15);
-		aml_isa_update_bits(ISA_TIMER_MUX, 1 << 19, 1 << 19);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 15, TIMERD_MODE << 15);
+		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 19, 1 << 19);
 		hw_timer_init = 1;
 	}
 	ret = request_irq(INT_TIMER_D, audio_isr_handler,
@@ -607,6 +596,10 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 {
 	int res = 0;
 	int n;
+#ifndef CONFIG_SND_AML_SPLIT_MODE
+	int i = 0, j = 0;
+	int align = runtime->channels * 32;
+#endif
 	unsigned long offset = frames_to_bytes(runtime, pos);
 	char *hwbuf = runtime->dma_area + offset;
 	struct aml_runtime_data *prtd = runtime->private_data;
@@ -616,8 +609,6 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	struct audio_stream *s = &prtd->s;
 	struct device *dev = substream->pcm->card->dev;
 #ifndef CONFIG_SND_AML_SPLIT_MODE
-	int i = 0, j = 0;
-	int align = runtime->channels * 32;
 	int cached_len = tmp_buf->cached_len;
 	char *cache_buffer_bytes = tmp_buf->cache_buffer_bytes;
 #endif
@@ -676,115 +667,51 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 		memcpy(hwbuf, ubuf, n);
 #else
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
-			int16_t *tfrom, *to;
+
+			int16_t *tfrom, *to, *left, *right;
 			tfrom = (int16_t *) ubuf;
 			to = (int16_t *) hwbuf;
 
-			if (runtime->channels == 8) {
-				int16_t *lf, *cf, *rf, *ls,
-						*rs, *lef, *sbl, *sbr;
-				lf = to;
-				cf = to + 16 * 1;
-				rf = to + 16 * 2;
-				ls = to + 16 * 3;
-				rs = to + 16 * 4;
-				lef = to + 16 * 5;
-				sbl = to + 16 * 6;
-				sbr = to + 16 * 7;
-				for (j = 0; j < n; j += 256) {
-					for (i = 0; i < 16; i++) {
-						*lf++ = (*tfrom++);
-						*cf++ = (*tfrom++);
-						*rf++ = (*tfrom++);
-						*ls++ = (*tfrom++);
-						*rs++ = (*tfrom++);
-						*lef++ = (*tfrom++);
-						*sbl++ = (*tfrom++);
-						*sbr++ = (*tfrom++);
-					}
-					lf += 7 * 16;
-					cf += 7 * 16;
-					rf += 7 * 16;
-					ls += 7 * 16;
-					rs += 7 * 16;
-					lef += 7 * 16;
-					sbl += 7 * 16;
-					sbr += 7 * 16;
-				}
-			} else if (runtime->channels == 2) {
-				int16_t *left, *right;
-				left = to;
-				right = to + 16;
+			left = to;
+			right = to + 16;
 
-				for (j = 0; j < n; j += 64) {
-					for (i = 0; i < 16; i++) {
-						*left++ = (*tfrom++);
-						*right++ = (*tfrom++);
-					}
-					left += 16;
-					right += 16;
+			for (j = 0; j < n; j += 64) {
+				for (i = 0; i < 16; i++) {
+					*left++ = (*tfrom++);
+					*right++ = (*tfrom++);
 				}
+				left += 16;
+				right += 16;
 			}
 		} else if (runtime->format == SNDRV_PCM_FORMAT_S24_LE
 			   && I2S_MODE == AIU_I2S_MODE_PCM24) {
-			int32_t *tfrom, *to;
+			int32_t *tfrom, *to, *left, *right;
 			tfrom = (int32_t *) ubuf;
 			to = (int32_t *) hwbuf;
 
-			if (runtime->channels == 8) {
-				int32_t *lf, *cf, *rf, *ls,
-					*rs, *lef, *sbl, *sbr;
-				lf = to;
-				cf = to + 8 * 1;
-				rf = to + 8 * 2;
-				ls = to + 8 * 3;
-				rs = to + 8 * 4;
-				lef = to + 8 * 5;
-				sbl = to + 8 * 6;
-				sbr = to + 8 * 7;
-				for (j = 0; j < n; j += 256) {
-					for (i = 0; i < 8; i++) {
-						*lf++ = (*tfrom++);
-						*cf++ = (*tfrom++);
-						*rf++ = (*tfrom++);
-						*ls++ = (*tfrom++);
-						*rs++ = (*tfrom++);
-						*lef++ = (*tfrom++);
-						*sbl++ = (*tfrom++);
-						*sbr++ = (*tfrom++);
-					}
-					lf += 7 * 8;
-					cf += 7 * 8;
-					rf += 7 * 8;
-					ls += 7 * 8;
-					rs += 7 * 8;
-					lef += 7 * 8;
-					sbl += 7 * 8;
-					sbr += 7 * 8;
-				}
-			} else if (runtime->channels == 2) {
-				int32_t *left, *right;
-				left = to;
-				right = to + 8;
+			left = to;
+			right = to + 8;
 
-				for (j = 0; j < n; j += 64) {
-					for (i = 0; i < 8; i++) {
-						*left++ = (*tfrom++);
-						*right++ = (*tfrom++);
-					}
-					left += 8;
-					right += 8;
+			for (j = 0; j < n; j += 64) {
+				for (i = 0; i < 8; i++) {
+					*left++ = (*tfrom++);
+					*right++ = (*tfrom++);
 				}
+				left += 8;
+				right += 8;
 			}
 
 		} else if (runtime->format == SNDRV_PCM_FORMAT_S32_LE) {
-			int32_t *tfrom, *to;
+			int32_t *tfrom, *to, *left, *right;
 			tfrom = (int32_t *) ubuf;
 			to = (int32_t *) hwbuf;
 
+			left = to;
+			right = to + 8;
+
 			if (runtime->channels == 8) {
-				int32_t *lf, *cf, *rf, *ls,
-					*rs, *lef, *sbl, *sbr;
+				int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl,
+				    *sbr;
 				lf = to;
 				cf = to + 8 * 1;
 				rf = to + 8 * 2;
@@ -813,11 +740,7 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 					sbl += 7 * 8;
 					sbr += 7 * 8;
 				}
-			} else if (runtime->channels == 2) {
-				int32_t *left, *right;
-				left = to;
-				right = to + 8;
-
+			} else {
 				for (j = 0; j < n; j += 64) {
 					for (i = 0; i < 8; i++) {
 						*left++ = (*tfrom++) >> 8;
@@ -902,30 +825,6 @@ static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
 				}
 				memset(hwbuf, 0, n);
 			}
-		} else if (runtime->channels == 8) {
-			/* for fifo0 1 ch mode, i2s_ctrl b[13:10]=0xf */
-			if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
-				char *hwbuf = runtime->dma_area + offset*2;
-				int32_t *tfrom = (int32_t *)hwbuf;
-				int16_t *to = (int16_t *)ubuf;
-				for (j = 0; j < n*2; j += 4) {
-					*to++ = (int16_t)(((*tfrom++) >> 8)
-							& 0xffff);
-				}
-				memset(hwbuf, 0, n*2);
-			} else {
-				/* S24_LE or S32_LE */
-				char *hwbuf = runtime->dma_area + offset;
-				int32_t *tfrom = (int32_t *)hwbuf;
-				int32_t *to = (int32_t *)ubuf;
-				if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
-					r_shift = 0;
-				for (j = 0; j < n; j += 4) {
-					*to++ = (int32_t)((*tfrom++)
-						       << r_shift);
-				}
-				memset(hwbuf, 0, n);
-			}
 		}
 	}
 	res = copy_to_user(buf, ubuf, n);
@@ -1188,8 +1087,8 @@ static unsigned long isa_timerd_saved;
 static unsigned long isa_timerd_mux_saved;
 static int aml_i2s_freeze(struct device *dev)
 {
-	isa_timerd_saved = aml_isa_read(ISA_TIMERD);
-	isa_timerd_mux_saved = aml_isa_read(ISA_TIMER_MUX);
+	isa_timerd_saved = aml_read_cbus(ISA_TIMERD);
+	isa_timerd_mux_saved = aml_read_cbus(ISA_TIMER_MUX);
 	return 0;
 }
 
@@ -1200,8 +1099,8 @@ static int aml_i2s_thaw(struct device *dev)
 
 static int aml_i2s_restore(struct device *dev)
 {
-	aml_isa_write(ISA_TIMERD, isa_timerd_saved);
-	aml_isa_write(ISA_TIMER_MUX, isa_timerd_mux_saved);
+	aml_write_cbus(ISA_TIMERD, isa_timerd_saved);
+	aml_write_cbus(ISA_TIMER_MUX, isa_timerd_mux_saved);
 	return 0;
 }
 
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index a6b228b..870ffb3 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -39,14 +39,11 @@
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 #include <sound/tlv.h>
-
-#include <linux/amlogic/cpu_version.h>
-#include <linux/amlogic/sound/aout_notify.h>
-
 #include "aml_i2s_dai.h"
 #include "aml_pcm.h"
 #include "aml_i2s.h"
 #include "aml_audio_hw.h"
+#include <linux/amlogic/sound/aout_notify.h>
 #include "aml_spdif_dai.h"
 
 struct aml_dai_info dai_info[3] = { {0} };
@@ -98,6 +95,8 @@ static struct channel_speaker_allocation channel_allocations[] = {
 
 
 /* extern int set_i2s_iec958_samesource(int enable); */
+#define DEFAULT_SAMPLERATE 48000
+#define DEFAULT_MCLK_RATIO_SR 256
 
 /*
 the I2S hw  and IEC958 PCM output initation,958 initation here,
@@ -363,7 +362,7 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
 	if (IEC958_mode_codec == 0)
-		aml_spdif_play(0);
+		aml_spdif_play(1);
 	return;
 }
 
@@ -385,7 +384,6 @@ static int aml_i2s_set_amclk(struct aml_i2s *i2s, unsigned long rate)
 		return ret;
 
 	audio_set_i2s_clk_div();
-	set_hdmi_tx_clk_source(2);
 
 	return 0;
 }
@@ -397,36 +395,35 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 	struct aml_runtime_data *prtd = runtime->private_data;
 	struct audio_stream *s = &prtd->s;
 	struct aml_i2s *i2s = snd_soc_dai_get_drvdata(dai);
-	audio_util_set_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		s->i2s_mode = dai_info[dai->id].i2s_mode;
 		if (runtime->format == SNDRV_PCM_FORMAT_S16_LE) {
 			audio_in_i2s_set_buf(runtime->dma_addr,
 					runtime->dma_bytes * 2,
-					0, i2s_pos_sync, i2s->audin_fifo_src,
-					runtime->channels);
+					0, i2s_pos_sync, i2s->audin_fifo_src);
 			memset((void *)runtime->dma_area, 0,
 					runtime->dma_bytes * 2);
 		} else {
 			audio_in_i2s_set_buf(runtime->dma_addr,
 					runtime->dma_bytes,
-					0, i2s_pos_sync, i2s->audin_fifo_src,
-					runtime->channels);
+					0, i2s_pos_sync, i2s->audin_fifo_src);
 			memset((void *)runtime->dma_area, 0,
 					runtime->dma_bytes);
 		}
 		s->device_type = AML_AUDIO_I2SIN;
 	} else {
 		s->device_type = AML_AUDIO_I2SOUT;
-		IEC958_mode_codec = 0;
 		audio_out_i2s_enable(0);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		IEC958_mode_codec = 0;
 		aml_hw_i2s_init(runtime);
 		/* i2s/958 share the same audio hw buffer when PCM mode */
 		if (IEC958_mode_codec == 0) {
 			aml_hw_iec958_init(substream, 1);
 			/* use the hw same sync for i2s/958 */
 			dev_info(substream->pcm->card->dev, "i2s/958 same source\n");
+			audio_i2s_958_same_source(1);
 		}
 		if (runtime->channels == 8) {
 			dev_info(substream->pcm->card->dev,
@@ -539,8 +536,9 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 	return 0;
 }
 
-#define AML_DAI_I2S_RATES		SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
-#define AML_DAI_I2S_FORMATS		SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.startup = aml_dai_i2s_startup,
@@ -593,14 +591,7 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(gate_names); i++) {
 		audio_reset = devm_reset_control_get(&pdev->dev, gate_names[i]);
 		if (IS_ERR(audio_reset)) {
-			dev_err(&pdev->dev, "Can't get aml audio gate:%s\n",
-				gate_names[i]);
-
-			if (1 == i && is_meson_txlx_cpu()) {
-				pr_info("ignore aud_buf gate for txlx\n");
-				continue;
-			}
-
+			dev_err(&pdev->dev, "Can't get aml audio gate\n");
 			return PTR_ERR(audio_reset);
 		}
 		reset_control_deassert(audio_reset);
@@ -638,7 +629,6 @@ static int aml_i2s_dai_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Can't set aml_i2s :%d\n", ret);
 		goto err;
 	}
-	audio_util_set_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 
 	ret = clk_prepare_enable(i2s->clk_mclk);
 	if (ret) {
diff --git a/sound/soc/aml/m8/aml_m8.c b/sound/soc/aml/m8/aml_m8.c
index 535bafc..812c2c2 100644
--- a/sound/soc/aml/m8/aml_m8.c
+++ b/sound/soc/aml/m8/aml_m8.c
@@ -48,7 +48,7 @@
 #include <linux/of_gpio.h>
 #include <linux/io.h>
 #include <linux/amlogic/jtag.h>
-#include <sound/tlv320aic32x4.h>
+
 
 #define DRV_NAME "aml_snd_m8_card"
 
@@ -56,7 +56,7 @@ static int i2sbuf[32 + 16];
 static void aml_i2s_play(void)
 {
 #if 0
-	audio_util_set_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+	audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 	audio_set_i2s_mode(AIU_I2S_MODE_PCM16, 2);
 #else
@@ -278,14 +278,15 @@ static int aml_suspend_pre(struct snd_soc_card *card)
 		mutex_unlock(&p_aml_audio->lock);
 	}
 
-	if (!IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
-		state = pinctrl_lookup_state(p_aml_audio->pin_ctl,
-				"aml_snd_suspend");
-		if (!IS_ERR(state)) {
-			pr_info("enter %s set pin_ctl suspend state\n",
-				__func__);
-			pinctrl_select_state(p_aml_audio->pin_ctl, state);
-		}
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to suspend\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_suspend");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl suspend state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
 	}
 
 	if (!IS_ERR(p_aml_audio->mute_desc)) {
@@ -328,14 +329,15 @@ static int aml_resume_post(struct snd_soc_card *card)
 		mutex_unlock(&p_aml_audio->lock);
 	}
 
-	if (!IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
-		state = pinctrl_lookup_state(p_aml_audio->pin_ctl,
-					"aml_snd_m8");
-		if (!IS_ERR(state)) {
-			pr_info("enter %s set pin_ctl working state\n",
-					__func__);
-		    pinctrl_select_state(p_aml_audio->pin_ctl, state);
-	    }
+	if (IS_ERR_OR_NULL(p_aml_audio->pin_ctl)) {
+		pr_info("no audio pin_ctrl to resume\n");
+		return 0;
+	}
+
+	state = pinctrl_lookup_state(p_aml_audio->pin_ctl, "aml_snd_m8");
+	if (!IS_ERR(state)) {
+		pr_info("enter %s set pin_ctl working state\n", __func__);
+		pinctrl_select_state(p_aml_audio->pin_ctl, state);
 	}
 
 	if (!IS_ERR(p_aml_audio->mute_desc)) {
@@ -402,57 +404,6 @@ static const struct snd_kcontrol_new aml_m8_controls[] = {
 			    aml_m8_set_spk),
 };
 
-static int aml_asoc_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params)
-{
-	int ret = 0;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-	pr_info("enter %s stream: %s rate: %d format: %d\n", __func__,
-			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
-				"playback" : "capture",
-			params_rate(params), params_format(params));
-	/* set codec DAI configuration */
-	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
-	if (ret < 0) {
-		pr_err("%s: set codec dai fmt failed!\n", __func__);
-		return ret;
-	}
-	/* set cpu DAI configuration */
-	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
-			SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
-	if (ret < 0) {
-		pr_err("%s: set cpu dai fmt failed!\n", __func__);
-		return ret;
-	}
-	/* set codec DAI clock */
-	ret = snd_soc_dai_set_sysclk(codec_dai, 0,
-			params_rate(params) * DEFAULT_MCLK_RATIO_SR,
-			SND_SOC_CLOCK_IN);
-	if (ret < 0) {
-		pr_err("%s: set codec dai sysclk failed (rate: %d)!\n",
-				__func__, params_rate(params));
-		return ret;
-	}
-	/* set cpu DAI clock */
-	ret = snd_soc_dai_set_sysclk(cpu_dai, 0,
-			params_rate(params) * DEFAULT_MCLK_RATIO_SR,
-			SND_SOC_CLOCK_OUT);
-	if (ret < 0) {
-		pr_err("%s: set cpu dai sysclk failed (rate: %d)!\n",
-				__func__, params_rate(params));
-		return ret;
-	}
-
-	return 0;
-}
-static struct snd_soc_ops aml_asoc_ops = {
-	.hw_params = aml_asoc_hw_params,
-};
-
 static int aml_asoc_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_card *card = rtd->card;
@@ -623,170 +574,6 @@ static int aml_card_dai_parse_of(struct device *dev,
 	return ret;
 }
 
-static int get_audio_codec_i2c_info(struct device_node *p_node,
-				struct aml_audio_codec_info *audio_codec_dev)
-{
-	const char *str;
-	int ret = 0;
-	unsigned i2c_addr;
-
-	ret = of_property_read_string(p_node, "codec_name",
-				      &audio_codec_dev->name);
-	if (ret) {
-		pr_info("get audio codec name failed!\n");
-		goto err_out;
-	}
-
-	ret = of_property_match_string(p_node, "status", "okay");
-	if (ret) {
-		pr_info("%s:this audio codec is disabled!\n",
-			audio_codec_dev->name);
-		goto err_out;
-	}
-
-	pr_debug("use audio aux codec %s\n", audio_codec_dev->name);
-
-	ret = of_property_read_string(p_node, "i2c_bus", &str);
-	if (ret) {
-		pr_err("%s: faild to get i2c_bus str,use default i2c bus!\n",
-		       audio_codec_dev->name);
-		audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-	} else {
-		if (!strncmp(str, "i2c_bus_ao", 10))
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_AO;
-		else if (!strncmp(str, "i2c_bus_b", 9))
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_B;
-		else if (!strncmp(str, "i2c_bus_c", 9))
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_C;
-		else if (!strncmp(str, "i2c_bus_d", 9))
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-		else if (!strncmp(str, "i2c_bus_a", 9))
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_A;
-		else
-			audio_codec_dev->i2c_bus_type = AML_I2C_BUS_D;
-	}
-
-	ret = of_property_read_u32(p_node, "i2c_addr", &i2c_addr);
-	if (!ret)
-		audio_codec_dev->i2c_addr = i2c_addr;
-	pr_info("audio aux codec addr: 0x%x, audio codec i2c bus: %d\n",
-	       audio_codec_dev->i2c_addr, audio_codec_dev->i2c_bus_type);
-err_out:
-	return ret;
-}
-
-static int aic32x4_of_get_resetpin_pdata(struct aic32x4_pdata *pdata,
-				 struct device_node *p_node)
-{
-	struct gpio_desc *reset_desc;
-	int reset_pin = 0;
-
-	reset_desc = of_get_named_gpiod_flags(p_node, "reset_pin", 0, NULL);
-	if (IS_ERR(reset_desc)) {
-		pr_err("%s fail to get reset pin from dts!\n", __func__);
-	} else {
-		reset_pin = desc_to_gpio(reset_desc);
-		gpio_request(reset_pin, NULL);
-		/* gpio_direction_output(reset_pin, GPIOF_OUT_INIT_HIGH);
-		msleep(10); */
-		gpio_direction_output(reset_pin, GPIOF_OUT_INIT_LOW);
-		usleep_range(10*1000, 10*1000+100);
-
-		pdata->rstn_gpio = reset_pin;
-		pr_info("%s pdata->rstn_gpio = %d!\n", __func__,
-			pdata->rstn_gpio);
-	}
-	return 0;
-}
-
-static int __maybe_unused aic32x4_reset(struct aic32x4_pdata *pdata, int val)
-{
-	if (pdata == NULL)
-		return 0;
-	if (pdata->rstn_gpio)
-		return gpio_direction_output(pdata->rstn_gpio, val);
-
-	return 0;
-}
-
-static int aml_multi_dev_parse_of(struct snd_soc_card *card,
-		struct aic32x4_pdata **ppriv)
-{
-	struct device_node *audio_codec_node = card->dev->of_node;
-	struct device_node *child, *codec_node;
-	struct i2c_board_info board_info;
-	struct i2c_adapter *adapter;
-	struct i2c_client *client[4];
-	struct aml_audio_codec_info temp_audio_codec;
-	struct aic32x4_pdata *pdata;
-	static const char *multi_dev;
-	int i = 0;
-
-	pr_info("%s ...\n", __func__);
-	if (multi_dev != NULL)
-		return 0;
-
-	if (of_property_read_string(audio_codec_node, "multi_dev",
-				&multi_dev)) {
-		pr_info("no multi dev!\n");
-		return -ENODEV;
-	}
-	pr_info("multi_dev name = %s\n", multi_dev);
-	child = of_get_child_by_name(audio_codec_node, multi_dev);
-	if (child == NULL) {
-		/* pr_info("failed to find multi dev node %s\n", multi_dev);*/
-		codec_node = of_parse_phandle(audio_codec_node,
-				"codec_list", 0);
-		child = of_parse_phandle(codec_node, "sound-dai", 0);
-		if (child == NULL) {
-			pr_err("%s final can not find of node for %s\n",
-					__func__, multi_dev);
-			return -1;
-		}
-	}
-
-	memset(&temp_audio_codec, 0, sizeof(struct aml_audio_codec_info));
-	/*pr_info("%s, child name:%s\n", __func__, child->name);*/
-
-	if (get_audio_codec_i2c_info(child, &temp_audio_codec) == 0) {
-		memset(&board_info, 0, sizeof(board_info));
-		strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
-		adapter = i2c_get_adapter(temp_audio_codec.i2c_bus_type);
-		if (adapter == NULL) {
-			pr_err("%s failed to i2c_get_adapter\n", __func__);
-			return -ENOMEM;
-		}
-		pdata = kzalloc(sizeof(struct aic32x4_pdata),
-				GFP_KERNEL);
-		if (!pdata) {
-			pr_err("error: malloc aic32x4_pdata!\n");
-			return -ENOMEM;
-		}
-		if (ppriv != NULL)
-			*ppriv = pdata;
-
-		aic32x4_of_get_resetpin_pdata(pdata, child);
-
-		for (i = 0; i < 4; i++) {
-			board_info.addr = temp_audio_codec.i2c_addr + i;
-			board_info.platform_data = pdata;
-			client[i] = i2c_new_device(adapter, &board_info);
-			if (client[i] == NULL) {
-				pr_err("%s id:%d failed to i2c_new_device\n",
-						__func__, i);
-				kfree(pdata);
-				return -ENOMEM;
-			}
-			client[i]->dev.platform_data = pdata;
-			client[i]->dev.of_node = child;
-		}
-		i2c_put_adapter(adapter);
-	}
-
-	pr_info("%s done\n", __func__);
-	return 0;
-}
-
 static int aml_card_dais_parse_of(struct snd_soc_card *card)
 {
 	struct device_node *np = card->dev->of_node;
@@ -866,8 +653,6 @@ static int aml_card_dais_parse_of(struct snd_soc_card *card)
 		    aml_card_dai_parse_of(dev, &dai_links[i], init, cpu_node,
 					  codec_node, plat_node);
 	}
-	if (NULL != strstr(dai_links[0].codec_dai_name, "tlv320aic32x4"))
-		dai_links[0].ops = &aml_asoc_ops;
 
  err:
 	return ret;
@@ -892,7 +677,6 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct snd_soc_card *card;
 	struct aml_audio_private_data *p_aml_audio;
-	struct aic32x4_pdata *aic32x4_p = NULL;
 	int ret;
 
 	p_aml_audio =
@@ -930,7 +714,6 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 			return ret;
 		}
 	}
-	aml_multi_dev_parse_of(card, &aic32x4_p);
 
 	ret = aml_card_dais_parse_of(card);
 	if (ret < 0) {
@@ -939,8 +722,6 @@ static int aml_m8_audio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	aic32x4_reset(aic32x4_p, 1); /* enable all tlv320aic32x4 */
-
 	card->suspend_pre = aml_suspend_pre,
 	card->suspend_post = aml_suspend_post,
 	card->resume_pre = aml_resume_pre,
diff --git a/sound/soc/aml/m8/aml_m8.h b/sound/soc/aml/m8/aml_m8.h
index 0967283..9c5f496 100644
--- a/sound/soc/aml/m8/aml_m8.h
+++ b/sound/soc/aml/m8/aml_m8.h
@@ -20,13 +20,6 @@
 
 #include <sound/soc.h>
 #include <linux/gpio/consumer.h>
-
-#define AML_I2C_BUS_AO 0
-#define AML_I2C_BUS_A 1
-#define AML_I2C_BUS_B 2
-#define AML_I2C_BUS_C 3
-#define AML_I2C_BUS_D 4
-
 struct aml_audio_private_data {
 #if 0
 
@@ -79,30 +72,7 @@ struct aml_audio_private_data {
 	struct work_struct pinmux_work;
 };
 
-struct aml_audio_codec_info {
-	const char *name;
-	const char *status;
-	struct device_node *p_node;
-	unsigned i2c_bus_type;
-	unsigned i2c_addr;
-	unsigned id_reg;
-	unsigned id_val;
-	unsigned capless;
-};
-
-struct codec_info {
-	char name[I2C_NAME_SIZE];
-	char name_bus[I2C_NAME_SIZE];
-};
-
-struct codec_probe_priv {
-	int num_eq;
-	struct tas57xx_eq_cfg *eq_configs;
-};
-
 void aml_spdif_pinmux_init(struct device *pdev);
 void aml_spdif_pinmux_deinit(struct device *pdev);
-extern int i2c_transfer(struct i2c_adapter *adap,
-		struct i2c_msg *msgs, int num);
 #endif
 
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index aeea5db..ac76ef6 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,8 +26,9 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
-#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 struct pinctrl *pin_spdif_ctl;
 struct device *spdif_dev;
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 3196e06..197f710 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -41,16 +41,14 @@
 #include <sound/pcm_params.h>
 
 #include <linux/amlogic/iomap.h>
+#include "aml_audio_hw.h"
+#include "aml_spdif_dai.h"
+#include "aml_i2s.h"
 #include <linux/amlogic/sound/aout_notify.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 #include <linux/amlogic/cpu_version.h>
 
-#include "aml_audio_hw.h"
-#include "aml_spdif_dai.h"
-#include "aml_i2s.h"
-
 /*
  0 --  other formats except(DD,DD+,DTS)
  1 --  DTS
@@ -67,7 +65,6 @@ struct aml_spdif {
 	struct clk *clk_spdif;
 	struct clk *clk_81;
 	int old_samplerate;
-	uint clk_div;
 	/* spdif dai data in source select.
 	* !Check this with chip spec.
 	*/
@@ -80,33 +77,10 @@ EXPORT_SYMBOL(clk81);
 static int old_samplerate = -1;
 static int flag_samesrc = -1;
 
-static void set_IEC958_clock_div(uint div)
-{
-	if (div == spdif_p->clk_div)
-		return;
-
-	if (div > 0 && div <= 4) {
-		pr_info("set 958 audio clk div %d\n", div);
-		audio_set_spdif_clk_div(div);
-		spdif_p->clk_div = div;
-	}
-}
-
-static inline bool is_meson_tv_chipset(void)
-{
-	int ret = false;
-
-	ret = is_meson_gxtvbb_cpu()
-			|| is_meson_txl_cpu()
-			|| is_meson_txlx_cpu();
-	return ret;
-}
-
 void aml_spdif_play(int samesrc)
 {
 #if 0
-	if (!is_meson_tv_chipset()) {
-		uint div = 0;
+	if (is_meson_gxtvbb_cpu() == false) {
 		static int iec958buf[32 + 16];
 		struct _aiu_958_raw_setting_t set;
 		struct _aiu_958_channel_status_t chstat;
@@ -133,22 +107,25 @@ void aml_spdif_play(int samesrc)
 			flag_samesrc = samesrc;
 			aml_set_spdif_clk(48000 * 512, samesrc);
 		}
-		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5 ||
+		/* Todo, div can be changed, for most case, div = 2 */
+		/* audio_set_spdif_clk_div(); */
+		/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
+		if (IEC958_mode_codec == 4	|| IEC958_mode_codec == 5 ||
 		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
 			pr_info("set 4x audio clk for 958\n");
-			div = 1;
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
 		} else if (samesrc) {
 			pr_info("share the same clock\n");
-			div = 2;
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
 		} else {
 			pr_info("set normal 512 fs /4 fs\n");
-			div = 4;
+			aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 		}
-
-		set_IEC958_clock_div(div);
+		/* enable 958 divider */
+		aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 		audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 		/*clear the same source function as new raw data output */
-		audio_i2s_958_same_source(samesrc);
+		audio_i2s_958_same_source(0);
 		memset(iec958buf, 0, sizeof(iec958buf));
 		audio_set_958outbuf((virt_to_phys(iec958buf) + 63) & (~63),
 					128, 0);
@@ -212,7 +189,6 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 	struct _aiu_958_raw_setting_t set;
 	struct _aiu_958_channel_status_t chstat;
 	unsigned iec958_mode;
-	int div;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (buf == NULL || runtime == NULL) {
@@ -239,7 +215,7 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 			break;
 		}
 		audio_out_i2s_enable(0);
-		audio_util_set_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
+		audio_util_set_dac_i2s_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 		audio_set_i2s_mode(i2s_mode, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
 #else
@@ -258,18 +234,21 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 		aml_set_spdif_clk(runtime->rate * 512, samesrc);
 	}
 
+	/* Todo, div can be changed, for most case, div = 2 */
+	/* audio_set_spdif_clk_div(); */
+	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
 	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
+		// IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
 	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
 		IEC958_mode_codec = 4; /* EAC3 */
 		pr_info("set 4x audio clk for 958\n");
-		div = 1;
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
 	} else if (samesrc) {
 		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
-		div = 2;
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 1 << 4);
 	} else if (runtime->rate == 48000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
 		IEC958_mode_codec = 2; /* AC3/DTS */
 		pr_info("set normal 512 fs /4 fs\n");
@@ -277,12 +256,13 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 	} else {
 		IEC958_mode_codec = 0;
 		pr_info("set normal 512 fs /4 fs\n");
-		div = 4;
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 3 << 4);
 	}
-	set_IEC958_clock_div(div);
+	/* enable 958 divider */
+	aml_cbus_update_bits(AIU_CLK_CTRL, 1 << 1, 1 << 1);
 	audio_util_set_dac_958_format(AUDIO_ALGOUT_DAC_FORMAT_DSP);
 	/*clear the same source function as new raw data output */
-	audio_i2s_958_same_source(samesrc);
+	audio_i2s_958_same_source(0);
 
 	switch (runtime->format) {
 	case SNDRV_PCM_FORMAT_S32:
@@ -308,7 +288,7 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 	set.chan_stat->chstat0_r = set.chan_stat->chstat0_l;
 
 	/* AES3+2 */
-	if (IEC958_mode_codec == 8) {
+	if (IEC958_mode_codec == 8 || IEC958_mode_codec == 7) {
 		set.chan_stat->chstat1_l = 0x0900;
 	} else if (runtime->rate == 192000) {
 		set.chan_stat->chstat1_l = 0x0e00;
@@ -334,8 +314,11 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 
 	/* notify hdmi to set audio type */
 	if (IEC958_mode_codec == 8) {
-		/* TrueHD/DTS-HD MA */
+		/* DTS-HD MA */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
+	} else if (IEC958_mode_codec == 7) {
+		/* TrueHD */
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP, substream);
 	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
 		/* AC3/DTS/EAC3 */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
@@ -413,6 +396,10 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 		       snd_pcm_lib_buffer_bytes(substream));
 		if (IEC958_mode_codec == 6)
 			pr_info("8chPCM output:disable aml_spdif_play\n");
+		else
+			;/*aml_spdif_play();*/
+
+		/* audio_spdifout_pg_enable(0); */
 	}
 
 }
@@ -420,7 +407,11 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *dai)
 {
+
+	/* struct snd_soc_pcm_runtime *rtd = substream->private_data; */
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	/* struct aml_runtime_data *prtd = runtime->private_data; */
+	/* audio_stream_t *s = &prtd->s; */
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		aml_hw_iec958_init(substream, 0);
-- 
2.7.4

From 03fd099a29d3aec88fade1148d77e214c53d681f Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 18:59:00 +0800
Subject: [PATCH] m8 audio remove txlx

---
 drivers/amlogic/amaudio/amaudio.c           |  22 +-
 drivers/amlogic/audiodsp/audiodsp_module.c  |  93 +---
 drivers/amlogic/audiodsp/dsp_control.c      |  35 +-
 drivers/amlogic/audiodsp/spdif_module.c     |  41 +-
 include/linux/amlogic/sound/aml_snd_iomap.h |  56 --
 sound/soc/aml/m8/Kconfig                    |   2 -
 sound/soc/aml/m8/Makefile                   |   4 -
 sound/soc/aml/m8/aml_audio_hw.c             | 768 ++++++++++++++++------------
 sound/soc/aml/m8/aml_audio_hw.h             |  22 +-
 sound/soc/aml/m8/aml_audio_hw_pcm.c         | 276 +++++-----
 sound/soc/aml/m8/aml_g9tv.c                 | 742 ++++++++++++++++-----------
 sound/soc/aml/m8/aml_g9tv.h                 |   9 +-
 sound/soc/aml/m8/aml_i2s.c                  | 183 ++-----
 sound/soc/aml/m8/aml_i2s_dai.c              |  36 +-
 sound/soc/aml/m8/aml_m8.c                   | 259 +---------
 sound/soc/aml/m8/aml_m8.h                   |  30 --
 sound/soc/aml/m8/aml_spdif_codec.c          |   5 +-
 sound/soc/aml/m8/aml_spdif_dai.c            |  85 ++-
 sound/soc/codecs/Kconfig                    |   3 -
 sound/soc/codecs/Makefile                   |   2 -
 sound/soc/codecs/aml_codec_txlx_acodec.c    | 727 --------------------------
 sound/soc/codecs/aml_codec_txlx_acodec.h    | 129 -----
 22 files changed, 1195 insertions(+), 2334 deletions(-)
 delete mode 100644 include/linux/amlogic/sound/aml_snd_iomap.h
 delete mode 100644 sound/soc/codecs/aml_codec_txlx_acodec.c
 delete mode 100644 sound/soc/codecs/aml_codec_txlx_acodec.h

diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index 553f460..5f1de09 100644
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -42,8 +42,6 @@
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
 #include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
-
 #include "amaudio.h"
 
 #define AMAUDIO_DEVICE_COUNT    ARRAY_SIZE(amaudio_ports)
@@ -287,8 +285,8 @@ static ssize_t output_enable_show(struct class *class,
 * this cause the player has no chance to  trigger the exit condition
 */
 	unsigned iec958_size =
-	    aml_aiu_read(AIU_MEM_IEC958_END_PTR) -
-	    aml_aiu_read(AIU_MEM_IEC958_START_PTR);
+	    aml_read_cbus(AIU_MEM_IEC958_END_PTR) -
+	    aml_read_cbus(AIU_MEM_IEC958_START_PTR);
 	/* normal spdif buffer MUST NOT less than 512 bytes */
 	return sprintf(buf, "%d\n", (if_audio_out_enable() ||
 			(if_958_audio_out_enable() && iec958_size > 512)));
@@ -328,7 +326,7 @@ static ssize_t record_type_show(struct class *class,
 	}
 }
 
-static int dtsm6_stream_type = -1;
+static unsigned int dtsm6_stream_type;
 static unsigned int dtsm6_apre_cnt;
 static unsigned int dtsm6_apre_sel;
 static unsigned int dtsm6_apre_assets_sel;
@@ -340,13 +338,13 @@ static ssize_t store_debug(struct class *class, struct class_attribute *attr,
 			   const char *buf, size_t count)
 {
 	if (strncmp(buf, "chstatus_set", 12) == 0) {
-		aml_aiu_write(AIU_958_VALID_CTRL, 0);
-		aml_aiu_write(AIU_958_CHSTAT_L0, 0x1900);
-		aml_aiu_write(AIU_958_CHSTAT_R0, 0x1900);
+		aml_write_cbus(AIU_958_VALID_CTRL, 0);
+		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1900);
+		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1900);
 	} else if (strncmp(buf, "chstatus_off", 12) == 0) {
-		aml_aiu_write(AIU_958_VALID_CTRL, 3);
-		aml_aiu_write(AIU_958_CHSTAT_L0, 0x1902);
-		aml_aiu_write(AIU_958_CHSTAT_R0, 0x1902);
+		aml_write_cbus(AIU_958_VALID_CTRL, 3);
+		aml_write_cbus(AIU_958_CHSTAT_L0, 0x1902);
+		aml_write_cbus(AIU_958_CHSTAT_R0, 0x1902);
 	} else if (strncmp(buf, "dtsm6_stream_type_set", 21) == 0) {
 		if (kstrtoint(buf + 21, 10, &dtsm6_stream_type))
 			return -EINVAL;
@@ -371,7 +369,7 @@ static ssize_t store_debug(struct class *class, struct class_attribute *attr,
 		if (kstrtoint(buf + 19, 10, &dtsm6_mulasset_hint))
 			return -EINVAL;
 	} else if (strncmp(buf, "dtsm6_clear_info", 16) == 0) {
-		dtsm6_stream_type = -1;
+		dtsm6_stream_type = 0;
 		dtsm6_apre_cnt = 0;
 		dtsm6_apre_sel = 0;
 		dtsm6_apre_assets_sel = 0;
diff --git a/drivers/amlogic/audiodsp/audiodsp_module.c b/drivers/amlogic/audiodsp/audiodsp_module.c
index 882ffa3..6e999c4 100644
--- a/drivers/amlogic/audiodsp/audiodsp_module.c
+++ b/drivers/amlogic/audiodsp/audiodsp_module.c
@@ -34,8 +34,6 @@
 #include <linux/slab.h>
 #include <linux/reset.h>
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
-#include <linux/amlogic/codec_mm/configs.h>
 
 /* #include <asm/dsp/audiodsp_control.h> */
 /* #include "audiodsp_control.h" */
@@ -851,12 +849,12 @@ static ssize_t audio_samesource_show(struct class *cla,
 {
 	char *pbuf = buf;
 	int samesource = 0;
-	int i2s_enable = !!(aml_aiu_read(AIU_MEM_I2S_CONTROL) & (3 << 1));
+	int i2s_enable = !!(aml_read_cbus(AIU_MEM_I2S_CONTROL) & (3 << 1));
 	int iec958_enable =
-	    !!(aml_aiu_read(AIU_MEM_IEC958_CONTROL) & (3 << 1));
+	    !!(aml_read_cbus(AIU_MEM_IEC958_CONTROL) & (3 << 1));
 	samesource =
-	    (aml_aiu_read(AIU_MEM_IEC958_START_PTR) ==
-	     aml_aiu_read(AIU_MEM_I2S_START_PTR));
+	    (aml_read_cbus(AIU_MEM_IEC958_START_PTR) ==
+	     aml_read_cbus(AIU_MEM_I2S_START_PTR));
 
 	/* make sure i2s/958 same source.and both enabled */
 	if (samesource == 0) {
@@ -1186,86 +1184,6 @@ static struct class audiodsp_class = {
 	.resume = NULL,
 #endif
 };
-int audiodsp_store_fun(const char *name, int id, const char *buf, int size)
-{
-	int ret = size;
-	switch (id) {
-	case 0:
-		ret = digital_raw_store(NULL, NULL , buf, size);
-		break;
-	case 1:
-		ret = ac3_drc_control_store(NULL, NULL , buf, size);
-		break;
-	case 2:
-		ret =  audio_samesource_store(NULL, NULL , buf, size);
-		break;
-	case 3:
-		ret = codec_fatal_err_store(NULL, NULL , buf, size);
-		break;
-	case 4:
-		ret = digital_codec_store(NULL, NULL , buf, size);
-		break;
-	case 5:
-		ret = dts_dec_control_store(NULL, NULL , buf, size);
-		break;
-	default:
-		ret = -1;
-	}
-	return size;
-
-}
-int audiodsp_show_fun(const char *trigger, int id, char *sbuf, int size)
-{
-	int ret = -1;
-	void *buf, *getbuf = NULL;
-	if (size < PAGE_SIZE) {
-		getbuf = (void *)__get_free_page(GFP_KERNEL);
-		if (!getbuf)
-			return -ENOMEM;
-		buf = getbuf;
-	} else {
-		buf = sbuf;
-	}
-	switch (id) {
-	case 0:
-		ret = digital_raw_show(NULL, NULL , buf);
-		break;
-	case 1:
-		ret = ac3_drc_control_show(NULL, NULL , buf);
-		break;
-	case 2:
-		ret =  audio_samesource_show(NULL, NULL , buf);
-		break;
-	case 3:
-		ret = codec_fatal_err_show(NULL, NULL , buf);
-		break;
-	case 4:
-		ret = digital_codec_show(NULL, NULL , buf);
-		break;
-	case 5:
-		ret = dts_dec_control_show(NULL, NULL , buf);
-		break;
-	default:
-		pr_err("unknow trigger:[%s]\n", trigger);
-		ret = -1;
-	}
-	if (ret > 0 && getbuf != NULL) {
-		ret = min_t(int, ret, size);
-		strncpy(sbuf, buf, ret);
-	}
-	if (getbuf != NULL)
-		free_page((unsigned long)getbuf);
-	return ret;
-}
-static struct mconfig audiodsp_config[] = {
-	MC_FUN_ID("digital_raw", audiodsp_show_fun, audiodsp_store_fun, 0),
-	MC_FUN_ID("ac3_drc_control", audiodsp_show_fun, audiodsp_store_fun, 1),
-	MC_FUN_ID("audio_samesource", audiodsp_show_fun, audiodsp_store_fun, 2),
-	MC_FUN_ID("codec_fatal_err", audiodsp_show_fun, audiodsp_store_fun, 3),
-	MC_FUN_ID("digital_codec", audiodsp_show_fun, audiodsp_store_fun, 4),
-	MC_FUN_ID("dts_dec_control", audiodsp_show_fun, audiodsp_store_fun, 5),
-};
-static struct mconfig_node audiodsp_node;
 
 int audiodsp_probe(void)
 {
@@ -1338,8 +1256,7 @@ int audiodsp_probe(void)
 #if 0
 	dsp_get_debug_interface(0);
 #endif
-	INIT_REG_NODE_CONFIGS("media.audio", &audiodsp_node,
-		"audiodsp", audiodsp_config, CONFIG_FOR_RW);
+
 	return res;
 
 	device_destroy(priv->class, MKDEV(AUDIODSP_MAJOR, 0));
diff --git a/drivers/amlogic/audiodsp/dsp_control.c b/drivers/amlogic/audiodsp/dsp_control.c
index 94e94fc..48ac8a9 100644
--- a/drivers/amlogic/audiodsp/dsp_control.c
+++ b/drivers/amlogic/audiodsp/dsp_control.c
@@ -33,7 +33,6 @@
 #include <linux/amlogic/amports/dsp_register.h>
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 
 #include "dsp_mailbox.h"
 #include <linux/delay.h>
@@ -63,15 +62,16 @@ static void enable_dsp(int flag)
 		/* enable */
 		SET_MPEG_REG_MASK(MEDIA_CPU_CTL, 3);
 	}
-#else if (!flag)
-	aml_isa_update_bits(MEDIA_CPU_CTL, 1, 0);
+#else				/*  */
+	if (!flag)
+		aml_cbus_update_bits(MEDIA_CPU_CTL, 1, 0);
 
-	aml_hiu_reset_update_bits(RESET2_REGISTER, RESET_AUD_ARC, 0);
+	aml_cbus_update_bits(RESET2_REGISTER, RESET_AUD_ARC, 0);
 	if (flag) {
-		aml_isa_update_bits(MEDIA_CPU_CTL, 1, 1);
-		aml_isa_update_bits(MEDIA_CPU_CTL, 1, 0);
+		aml_cbus_update_bits(MEDIA_CPU_CTL, 1, 1);
+		aml_cbus_update_bits(MEDIA_CPU_CTL, 1, 0);
 	}
-#endif
+#endif				/*  */
 }
 
 void halt_dsp(struct audiodsp_priv *priv)
@@ -91,7 +91,7 @@ void halt_dsp(struct audiodsp_priv *priv)
 			DSP_PRNT
 				("dsp isn't sleeping when call dsp_stop\n");
 
-#else
+#else				/*  */
 		for (i = 0; i < 10; i++) {
 			dsp_mailbox_send(priv, 1, M2B_IRQ0_DSP_HALT, 0, 0, 0);
 			udelay(1000);	/*waiting arc2 self-halt */
@@ -101,14 +101,14 @@ void halt_dsp(struct audiodsp_priv *priv)
 		if (i == 10)
 			DSP_PRNT("warning,dsp self-halt time out\n");
 
-#endif
+#endif				/*  */
 	}
 #ifdef AUDIODSP_RESET
 	if (DSP_RD(DSP_STATUS) != DSP_STATUS_RUNING) {
 		DSP_WD(DSP_STATUS, DSP_STATUS_HALT);
 		return;
 	}
-#endif
+#endif				/*  */
 	if (!priv->dsp_is_started) {
 		enable_dsp(0);	/*hardware halt the cpu */
 		DSP_WD(DSP_STATUS, DSP_STATUS_HALT);
@@ -128,13 +128,14 @@ void reset_dsp(struct audiodsp_priv *priv)
 			   ((AUDIO_DSP_START_PHY_ADDR) >> 20) << 20);
 	SET_MPEG_REG_MASK(MEDIA_CPU_CTL, 1 << 16);
 
-#else
-	aml_isa_update_bits(MEDIA_CPU_CTL, (0xfff << 4), 0);
-	aml_isa_update_bits(MEDIA_CPU_CTL,
+#else				/*  */
+	aml_cbus_update_bits(MEDIA_CPU_CTL, (0xfff << 4), 0);
+	aml_cbus_update_bits(MEDIA_CPU_CTL,
 			      ((AUDIO_DSP_START_PHY_ADDR) >> 20) << 4,
 			      ((AUDIO_DSP_START_PHY_ADDR) >> 20) << 4);
 
-#endif	/* decode option */
+#endif				/*  */
+	/* decode option */
 	if (audioin_mode & 2)
 		decopt &= ~(1 << 6);
 
@@ -355,7 +356,7 @@ int dsp_stop(struct audiodsp_priv *priv)
 #ifdef AUDIODSP_RESET
 	priv->dsp_is_started = 0;
 
-#endif
+#endif				/*  */
 	halt_dsp(priv);
 	priv->dsp_end_time = jiffies;
 
@@ -373,7 +374,7 @@ int dsp_stop(struct audiodsp_priv *priv)
 		kfree(priv->stream_buffer_mem);
 		priv->stream_buffer_mem = NULL;
 	}
-#endif
+#endif				/*  */
 	mutex_unlock(&priv->dsp_mutex);
 	return 0;
 }
@@ -386,7 +387,7 @@ int dsp_check_status(struct audiodsp_priv *priv)
 	int pcmlevel = 0;
 	if (DSP_RD(DSP_STATUS) != DSP_STATUS_RUNING)
 		return 1;
-	ablevel = aml_aiu_read(AIU_MEM_AIFIFO_LEVEL);
+	ablevel = aml_read_cbus(AIU_MEM_AIFIFO_LEVEL);
 	pcmlevel = dsp_codec_get_bufer_data_len(priv);
 	if ((ablevel == priv->last_ablevel && ablevel > 50 * 1024) &&
 		(pcmlevel == priv->last_pcmlevel && pcmlevel < 512)) {
diff --git a/drivers/amlogic/audiodsp/spdif_module.c b/drivers/amlogic/audiodsp/spdif_module.c
index 6c61bec..ef27398 100644
--- a/drivers/amlogic/audiodsp/spdif_module.c
+++ b/drivers/amlogic/audiodsp/spdif_module.c
@@ -26,7 +26,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/amlogic/amports/dsp_register.h>
 #include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
 #include <linux/amlogic/iomap.h>
 
 #include "spdif_module.h"
@@ -41,24 +40,24 @@ static unsigned iec958_wr_offset;
 
 static inline int if_audio_output_iec958_enable(void)
 {
-	return aml_aiu_read(AIU_MEM_IEC958_CONTROL) && (0x3 << 1);
+	return aml_read_cbus(AIU_MEM_IEC958_CONTROL) && (0x3 << 1);
 }
 
 static inline int if_audio_output_i2s_enable(void)
 {
-	return aml_aiu_read(AIU_MEM_I2S_CONTROL) && (0x3 << 1);
+	return aml_read_cbus(AIU_MEM_I2S_CONTROL) && (0x3 << 1);
 }
 
 static inline void audio_output_iec958_enable(unsigned flag)
 {
 	if (flag) {
-		aml_aiu_write(AIU_958_FORCE_LEFT, 0);
-		aml_aiu_update_bits(AIU_958_DCU_FF_CTRL, 1, 1);
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
+		aml_write_cbus(AIU_958_FORCE_LEFT, 0);
+		aml_cbus_update_bits(AIU_958_DCU_FF_CTRL, 1, 1);
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1,
 				0x3 << 1);
 	} else {
-		aml_aiu_write(AIU_958_DCU_FF_CTRL, 0);
-		aml_aiu_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1, 0);
+		aml_write_cbus(AIU_958_DCU_FF_CTRL, 0);
+		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 0x3 << 1, 0);
 	}
 }
 
@@ -93,18 +92,18 @@ static long audio_spdif_ioctl(struct file *file, unsigned int cmd,
 	switch (cmd) {
 	case AUDIO_SPDIF_GET_958_BUF_RD_OFFSET:
 		tmp =
-		aml_aiu_read(AIU_MEM_IEC958_RD_PTR) -
-		aml_aiu_read(AIU_MEM_IEC958_START_PTR);
+		aml_read_cbus(AIU_MEM_IEC958_RD_PTR) -
+		aml_read_cbus(AIU_MEM_IEC958_START_PTR);
 		put_user(tmp, (__s32 __user *) args);
 		break;
 	case AUDIO_SPDIF_GET_958_BUF_SIZE:
 		/* iec958_info.iec958_buffer_size; */
-		tmp = aml_aiu_read(AIU_MEM_IEC958_END_PTR) -
-			aml_aiu_read(AIU_MEM_IEC958_START_PTR) + 64;
+		tmp = aml_read_cbus(AIU_MEM_IEC958_END_PTR) -
+			aml_read_cbus(AIU_MEM_IEC958_START_PTR) + 64;
 		if (tmp == 64)
 			tmp = 0;
-		if (aml_aiu_read(AIU_MEM_IEC958_START_PTR) ==
-		aml_aiu_read(AIU_MEM_I2S_START_PTR)) {
+		if (aml_read_cbus(AIU_MEM_IEC958_START_PTR) ==
+		aml_read_cbus(AIU_MEM_I2S_START_PTR)) {
 			tmp = tmp * 4;
 		}
 		put_user(tmp, (__s32 __user *) args);
@@ -146,7 +145,7 @@ static ssize_t audio_spdif_write(struct file *file,
 	char *wr_ptr;
 	unsigned long wr_addr;
 	dma_addr_t buf_map;
-	wr_addr = aml_aiu_read(AIU_MEM_IEC958_START_PTR) + iec958_wr_offset;
+	wr_addr = aml_read_cbus(AIU_MEM_IEC958_START_PTR) + iec958_wr_offset;
 	wr_ptr = (char *)phys_to_virt(wr_addr);
 	if (copy_from_user((void *)wr_ptr, (void *)userbuf, len) != 0) {
 		pr_info("audio spdif: copy from user failed\n");
@@ -173,7 +172,7 @@ static int audio_spdif_mmap(struct file *file, struct vm_area_struct *vma)
 		return -EAGAIN;
 	}
 	/* mapping the 958 dma buffer to user space to write */
-	off = aml_aiu_read(AIU_MEM_IEC958_START_PTR);
+	off = aml_read_cbus(AIU_MEM_IEC958_START_PTR);
 
 	/*|VM_MAYWRITE|VM_MAYSHARE */
 	vma->vm_flags |=
@@ -187,8 +186,8 @@ static int audio_spdif_mmap(struct file *file, struct vm_area_struct *vma)
 	}
 	pr_info("audio spdif: mmap finished\n");
 	pr_info("audio spdif: 958 dma buf:py addr 0x%x,vir addr 0x%x\n",
-	aml_aiu_read(AIU_MEM_IEC958_START_PTR), (unsigned int)
-		phys_to_virt(aml_aiu_read(AIU_MEM_IEC958_START_PTR)));
+	aml_read_cbus(AIU_MEM_IEC958_START_PTR), (unsigned int)
+		phys_to_virt(aml_read_cbus(AIU_MEM_IEC958_START_PTR)));
 	return 0;
 }
 
@@ -199,8 +198,8 @@ static ssize_t audio_spdif_ptr_show(struct class *class,
 	ret = sprintf(buf, "iec958 buf runtime info:\n"
 		"  iec958 rd ptr :\t%x\n"
 		"  iec958 wr ptr :\t%x\n",
-		aml_aiu_read(AIU_MEM_IEC958_RD_PTR),
-		(aml_aiu_read(AIU_MEM_IEC958_START_PTR) +
+		aml_read_cbus(AIU_MEM_IEC958_RD_PTR),
+		(aml_read_cbus(AIU_MEM_IEC958_START_PTR) +
 			iec958_wr_offset));
 	return ret;
 }
@@ -210,7 +209,7 @@ static ssize_t audio_spdif_buf_show(struct class *class,
 {
 	ssize_t ret = 0;
 	unsigned *ptr =
-		(unsigned *)phys_to_virt(aml_aiu_read(AIU_MEM_IEC958_RD_PTR) +
+		(unsigned *)phys_to_virt(aml_read_cbus(AIU_MEM_IEC958_RD_PTR) +
 				iec958_wr_offset);
 	ret =
 		sprintf(buf,
diff --git a/include/linux/amlogic/sound/aml_snd_iomap.h b/include/linux/amlogic/sound/aml_snd_iomap.h
deleted file mode 100644
index 24c745d..0000000
--- a/include/linux/amlogic/sound/aml_snd_iomap.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * sound/soc/aml/m8/aml_snd_iomap.h
- *
- * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#ifndef AML_SND_IOMAP_H
-#define AML_SND_IOMAP_H
-#include <linux/platform_device.h>
-
-enum{
-	IO_AUDIN_BASE = 0,
-	IO_AIU_BASE,
-	IO_EQDRC_BASE,
-	IO_HIU_RESET_BASE,
-	IO_ISA_BASE,
-	IO_BASE_MAX,
-};
-
-extern int aml_audin_read(unsigned int short_reg);
-extern void aml_audin_write(unsigned int short_reg, unsigned int val);
-extern void aml_audin_update_bits(unsigned int short_reg,
-			unsigned int mask, unsigned int val);
-
-extern int aml_aiu_read(unsigned int short_reg);
-extern void aml_aiu_write(unsigned int short_reg, unsigned int val);
-extern void aml_aiu_update_bits(unsigned int short_reg,
-			unsigned int mask, unsigned int val);
-
-extern int aml_eqdrc_read(unsigned int short_reg);
-extern void aml_eqdrc_write(unsigned int short_reg, unsigned int val);
-extern void aml_eqdrc_update_bits(unsigned int short_reg,
-			unsigned int mask, unsigned int val);
-
-extern int aml_hiu_reset_read(unsigned int short_reg);
-extern void aml_hiu_reset_write(unsigned int short_reg, unsigned int val);
-extern void aml_hiu_reset_update_bits(unsigned int short_reg,
-			unsigned int mask, unsigned int val);
-
-extern int aml_isa_read(unsigned int short_reg);
-extern void aml_isa_write(unsigned int short_reg, unsigned int val);
-extern void aml_isa_update_bits(unsigned int short_reg,
-			unsigned int mask, unsigned int val);
-
-#endif
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index c54c628..69b0a56 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -590,6 +590,3 @@ config SND_SOC_AMLT9015
 
 config SND_SOC_AMLT9015S
 	tristate
-
-config SND_SOC_AMLTXLX_ACODEC
-	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a47b7c9..711ef11 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -129,7 +129,6 @@ snd-soc-pcm2bt-objs  := pcm2bt.o
 snd-soc-amlpmu4-objs := aml_pmu4_codec.o
 snd-soc-aml_t9015-objs := aml_codec_t9015.o
 snd-soc-aml_t9015S-objs := aml_codec_t9015S.o
-snd-soc-aml_txlx_acodec-objs := aml_codec_txlx_acodec.o
 snd-soc-es8323-objs := es8323.o
 
 # Amp
@@ -269,7 +268,6 @@ obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
 obj-$(CONFIG_SND_SOC_AMLPMU4)	+= snd-soc-amlpmu4.o
 obj-$(CONFIG_SND_SOC_AMLT9015)	+= snd-soc-aml_t9015.o
 obj-$(CONFIG_SND_SOC_AMLT9015S)	+= snd-soc-aml_t9015S.o
-obj-$(CONFIG_SND_SOC_AMLTXLX_ACODEC) += snd-soc-aml_txlx_acodec.o
 obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
 
 # Amp
diff --git a/sound/soc/codecs/aml_codec_txlx_acodec.c b/sound/soc/codecs/aml_codec_txlx_acodec.c
deleted file mode 100644
index 2268b4e..0000000
--- a/sound/soc/codecs/aml_codec_txlx_acodec.c
+++ /dev/null
@@ -1,727 +0,0 @@
-/*
- * linux/sound/soc/codecs/aml_codec_txlx_acodec.c
- *
- * Copyright 2017 AMLogic, Inc.
- *
- * Author: Xing Wang <xing.wang@amlogic.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-#include <linux/regmap.h>
-
-#include <linux/amlogic/iomap.h>
-#include <linux/amlogic/sound/aiu_regs.h>
-#include <linux/amlogic/sound/audin_regs.h>
-#include <linux/amlogic/sound/aml_snd_iomap.h>
-
-#include "aml_codec_txlx_acodec.h"
-
-struct txlx_acodec_priv {
-	struct snd_soc_codec *codec;
-	struct snd_pcm_hw_params *params;
-	struct regmap *regmap;
-};
-
-static const struct reg_default txlx_acodec_init_list[] = {
-	/* {AUDIO_CONFIG_BLOCK_ENABLE, 0x3400BCFF}, */
-	{ADC_VOL_CTR_PGA_IN_CONFIG, 0x50502929},
-	{DAC_VOL_CTR_DAC_SOFT_MUTE, 0xFBFB0000},
-	{LINE_OUT_CONFIG, 0x00004444},
-	{POWER_CONFIG, 0x00010000},
-	/* {ACODEC_DAC2_CONFIG, 0xFBFB0030}, */
-	{ACODEC_DAC2_CONFIG2, 0x0},
-	{ACODEC_7, 0x0}
-};
-
-static int txlx_acodec_reg_init(struct snd_soc_codec *codec)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(txlx_acodec_init_list); i++)
-		snd_soc_write(codec, txlx_acodec_init_list[i].reg,
-				txlx_acodec_init_list[i].def);
-
-	/*DAC 1 and DAC 2 be enable in the same time */
-	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0x3400BCFF);
-	snd_soc_write(codec, ACODEC_DAC2_CONFIG, 0xFBFB0030);
-
-	return 0;
-}
-
-static int aml_DAC_Gain_get_enum(
-	struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 add = ADC_VOL_CTR_PGA_IN_CONFIG;
-	u32 val = snd_soc_read(codec, add);
-	u32 val1 = (val & (0x1 <<  REG_DAC_GAIN_SEL_0))
-					>> REG_DAC_GAIN_SEL_0;
-	u32 val2 = (val & (0x1 <<  REG_DAC_GAIN_SEL_1))
-					>> (REG_DAC_GAIN_SEL_1 - 1);
-	val = val1 | val2;
-
-	ucontrol->value.enumerated.item[0] = val;
-	return 0;
-}
-
-static int aml_DAC_Gain_set_enum(
-	struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	u32 add = ADC_VOL_CTR_PGA_IN_CONFIG;
-	u32 val = snd_soc_read(codec, add);
-
-	if (ucontrol->value.enumerated.item[0] == 0) {
-		val &= ~(0x1 << REG_DAC_GAIN_SEL_1);
-		val &= ~(0x1 << REG_DAC_GAIN_SEL_0);
-	} else if (ucontrol->value.enumerated.item[0] == 1) {
-		val &= ~(0x1 << REG_DAC_GAIN_SEL_1);
-		val |= (0x1 << REG_DAC_GAIN_SEL_0);
-		pr_info("It has risk of distortion!\n");
-	} else if (ucontrol->value.enumerated.item[0] == 2) {
-		val |= (0x1 << REG_DAC_GAIN_SEL_1);
-		val &= ~(0x1 << REG_DAC_GAIN_SEL_0);
-		pr_info("It has risk of distortion!\n");
-	} else if (ucontrol->value.enumerated.item[0] == 3) {
-		val |= (0x1 << REG_DAC_GAIN_SEL_1);
-		val |= (0x1 << REG_DAC_GAIN_SEL_0);
-		pr_info("It has risk of distortion!\n");
-	}
-
-	snd_soc_write(codec, val, add);
-	return 0;
-}
-
-static const DECLARE_TLV_DB_SCALE(pga_in_tlv, -1200, 250, 1);
-static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -29625, 375, 1);
-static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -95250, 375, 1);
-static const DECLARE_TLV_DB_SCALE(dac2_vol_tlv, -95250, 375, 1);
-
-static const char *const DAC_Gain_texts[] = { "0dB", "6dB", "12dB", "18dB" };
-
-static const struct soc_enum DAC_Gain_enum = SOC_ENUM_SINGLE(
-			SND_SOC_NOPM, 0, ARRAY_SIZE(DAC_Gain_texts),
-			DAC_Gain_texts);
-
-static const struct snd_kcontrol_new txlx_acodec_snd_controls[] = {
-	/*PGA_IN Gain */
-	SOC_DOUBLE_TLV("PGA IN Gain", ADC_VOL_CTR_PGA_IN_CONFIG,
-		       PGAL_IN_GAIN, PGAR_IN_GAIN,
-		       0x1f, 0, pga_in_tlv),
-
-	/*ADC Digital Volume control */
-	SOC_DOUBLE_TLV("ADC Digital Capture Volume", ADC_VOL_CTR_PGA_IN_CONFIG,
-		       ADCL_VC, ADCR_VC,
-		       0x7f, 0, adc_vol_tlv),
-
-	/*DAC Digital Volume control */
-	SOC_DOUBLE_TLV("DAC Digital Playback Volume",
-			   DAC_VOL_CTR_DAC_SOFT_MUTE,
-			   DACL_VC, DACR_VC,
-			   0xff, 0, dac_vol_tlv),
-
-	/*DAC 2 Digital Volume control */
-	SOC_DOUBLE_TLV("DAC 2 Digital Playback Volume",
-			   ACODEC_DAC2_CONFIG,
-			   DAC2L_VC, DAC2R_VC,
-			   0xff, 0, dac2_vol_tlv),
-
-    /*DAC extra Digital Gain control */
-	SOC_ENUM_EXT("DAC Extra Digital Gain",
-			   DAC_Gain_enum,
-			   aml_DAC_Gain_get_enum,
-			   aml_DAC_Gain_set_enum),
-
-	/* TODO: DAC 2 extra Digital Gain control */
-};
-
-/*pgain Left Channel Input */
-static const char * const linein_left_txt[] = {
-	"None", "AIL1", "AIL2", "AIL3", "AIL4"
-};
-
-static const SOC_ENUM_SINGLE_DECL(linein_left_enum,
-				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
-				  PGAL_IN_SEL, linein_left_txt);
-
-static const struct snd_kcontrol_new lil_mux =
-SOC_DAPM_ENUM("ROUTE_L", linein_left_enum);
-
-/*pgain right Channel Input */
-static const char * const linein_right_txt[] = {
-	"None", "AIR1", "AIR2", "AIR3", "AIR4"
-};
-
-static const SOC_ENUM_SINGLE_DECL(linein_right_enum,
-				  ADC_VOL_CTR_PGA_IN_CONFIG   ,
-				  PGAR_IN_SEL, linein_right_txt);
-
-static const struct snd_kcontrol_new lir_mux =
-SOC_DAPM_ENUM("ROUTE_R", linein_right_enum);
-
-
-/*line out 1 Left mux */
-static const char * const out_l1l_txt[] = {
-	"None", "LO1L_SEL_AIL_INV", "LO1L_SEL_AIL", "Reserved", "LO1L_SEL_DACL"
-};
-
-static const SOC_ENUM_SINGLE_DECL(out_lo1l_enum, LINE_OUT_CONFIG,
-				  LO1L_SEL_AIL_INV, out_l1l_txt);
-
-static const struct snd_kcontrol_new lo1l_mux =
-SOC_DAPM_ENUM("LO1L_MUX", out_lo1l_enum);
-
-/*line out 1 right mux */
-static const char * const out_l1r_txt[] = {
-	"None", "LO1R_SEL_AIL", "LO1R_SEL_DACL", "Reserved", "LO1R_SEL_DACL_INV"
-};
-
-static const SOC_ENUM_SINGLE_DECL(out_lo1r_enum, LINE_OUT_CONFIG,
-				  LO1R_SEL_AIL, out_l1r_txt);
-
-static const struct snd_kcontrol_new lo1r_mux =
-SOC_DAPM_ENUM("LO1R_MUX", out_lo1r_enum);
-
-/*line out 2 left mux */
-static const char * const out_l2ol_txt[] = {
-	"None", "LO2L_SEL_AIR_INV", "LO2L_SEL_AIR", "Reserved", "LO2L_SEL_DACR"
-};
-
-static const SOC_ENUM_SINGLE_DECL(out_lo2l_enum, LINE_OUT_CONFIG,
-				  LO2L_SEL_AIR_INV, out_l2ol_txt);
-
-static const struct snd_kcontrol_new lo2l_mux =
-SOC_DAPM_ENUM("LO2L_MUX", out_lo2l_enum);
-
-/*line out 2 Right mux */
-static const char * const out_lo2r_txt[] = {
-	"None", "LO2R_SEL_AIR", "LO2R_SEL_DACR", "Reserved", "LO2R_SEL_DACR_INV"
-};
-
-static const SOC_ENUM_SINGLE_DECL(out_lo2r_enum, LINE_OUT_CONFIG,
-				  LO2R_SEL_AIR, out_lo2r_txt);
-
-static const struct snd_kcontrol_new lo2r_mux =
-SOC_DAPM_ENUM("LO2R_MUX", out_lo2r_enum);
-
-
-static const struct snd_soc_dapm_widget txlx_acodec_dapm_widgets[] = {
-
-	/* Input */
-	SND_SOC_DAPM_INPUT("Linein left 1"),
-	SND_SOC_DAPM_INPUT("Linein left 2"),
-	SND_SOC_DAPM_INPUT("Linein left 3"),
-	SND_SOC_DAPM_INPUT("Linein left 4"),
-
-	SND_SOC_DAPM_INPUT("Linein right 1"),
-	SND_SOC_DAPM_INPUT("Linein right 2"),
-	SND_SOC_DAPM_INPUT("Linein right 3"),
-	SND_SOC_DAPM_INPUT("Linein right 4"),
-
-	/*PGA input */
-	SND_SOC_DAPM_PGA("PGAL_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
-			 PGAL_IN_EN, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("PGAR_IN_EN", AUDIO_CONFIG_BLOCK_ENABLE,
-			 PGAR_IN_EN, 0, NULL, 0),
-
-	/*PGA input source select */
-	SND_SOC_DAPM_MUX("Linein left switch", SND_SOC_NOPM,
-			 0, 0, &lil_mux),
-	SND_SOC_DAPM_MUX("Linein right switch", SND_SOC_NOPM,
-			 0, 0, &lir_mux),
-
-	/*ADC capture stream */
-	SND_SOC_DAPM_ADC("Left ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
-			 ADCL_EN, 0),
-	SND_SOC_DAPM_ADC("Right ADC", "HIFI Capture", AUDIO_CONFIG_BLOCK_ENABLE,
-			 ADCR_EN, 0),
-
-	/*Output */
-	SND_SOC_DAPM_OUTPUT("Lineout 1 left"),
-	SND_SOC_DAPM_OUTPUT("Lineout 1 right"),
-	SND_SOC_DAPM_OUTPUT("Lineout 2 left"),
-	SND_SOC_DAPM_OUTPUT("Lineout 2 right"),
-
-	/*DAC playback stream */
-	SND_SOC_DAPM_DAC("Left DAC", "HIFI Playback",
-			 AUDIO_CONFIG_BLOCK_ENABLE,
-			 DACL_EN, 0),
-	SND_SOC_DAPM_DAC("Right DAC", "HIFI Playback",
-			 AUDIO_CONFIG_BLOCK_ENABLE,
-			 DACR_EN, 0),
-
-	/*DAC 2 playback stream */
-	SND_SOC_DAPM_DAC("Left DAC2", "HIFI Playback 2",
-			 ACODEC_DAC2_CONFIG,
-			 DAC2L_EN, 0),
-	SND_SOC_DAPM_DAC("Right DAC2", "HIFI Playback 2",
-			 ACODEC_DAC2_CONFIG,
-			 DAC2R_EN, 0),
-
-	/*DRV output */
-	SND_SOC_DAPM_OUT_DRV("LO1L_OUT_EN", SND_SOC_NOPM,
-			     0, 0, NULL, 0),
-	SND_SOC_DAPM_OUT_DRV("LO1R_OUT_EN", SND_SOC_NOPM,
-			     0, 0, NULL, 0),
-	SND_SOC_DAPM_OUT_DRV("LO2L_OUT_EN", SND_SOC_NOPM,
-			     0, 0, NULL, 0),
-	SND_SOC_DAPM_OUT_DRV("LO2R_OUT_EN", SND_SOC_NOPM,
-			     0, 0, NULL, 0),
-
-	/*MUX output source select */
-	SND_SOC_DAPM_MUX("Lineout 1 left switch", SND_SOC_NOPM,
-			 0, 0, &lo1l_mux),
-	SND_SOC_DAPM_MUX("Lineout 1 right switch", SND_SOC_NOPM,
-			 0, 0, &lo1r_mux),
-	SND_SOC_DAPM_MUX("Lineout 2 left switch", SND_SOC_NOPM,
-			 0, 0, &lo2l_mux),
-	SND_SOC_DAPM_MUX("Lineout 2 right switch", SND_SOC_NOPM,
-			 0, 0, &lo2r_mux),
-
-};
-
-static const struct snd_soc_dapm_route txlx_acodec_dapm_routes[] = {
-/* Input path */
-	{"Linein left switch", "AIL1", "Linein left 1"},
-	{"Linein left switch", "AIL2", "Linein left 2"},
-	{"Linein left switch", "AIL3", "Linein left 3"},
-	{"Linein left switch", "AIL4", "Linein left 4"},
-
-	{"Linein right switch", "AIR1", "Linein right 1"},
-	{"Linein right switch", "AIR2", "Linein right 2"},
-	{"Linein right switch", "AIR3", "Linein right 3"},
-	{"Linein right switch", "AIR4", "Linein right 4"},
-
-	{"PGAL_IN_EN", NULL, "Linein left switch"},
-	{"PGAR_IN_EN", NULL, "Linein right switch"},
-
-	{"Left ADC", NULL, "PGAL_IN_EN"},
-	{"Right ADC", NULL, "PGAR_IN_EN"},
-
-/*Output path*/
-	{"Lineout 1 left switch", "LO1L_SEL_DACL", "Left DAC"},
-	{"Lineout 1 left switch", "LO1L_SEL_AIL", "PGAL_IN_EN"},
-	{"Lineout 1 left switch", "LO1L_SEL_AIL_INV", "PGAL_IN_EN"},
-
-	{"Lineout 1 right switch", "LO1R_SEL_AIL", "PGAL_IN_EN"},
-	{"Lineout 1 right switch", "LO1R_SEL_DACL", "Left DAC"},
-	{"Lineout 1 right switch", "LO1R_SEL_DACL_INV", "Left DAC"},
-
-	{"Lineout 2 left switch", "LO2L_SEL_DACR", "Right DAC2"},
-	{"Lineout 2 left switch", "LO2L_SEL_AIR", "PGAR_IN_EN"},
-	{"Lineout 2 left switch", "LO2L_SEL_AIR_INV", "PGAR_IN_EN"},
-
-	{"Lineout 2 right switch", "LO2R_SEL_AIR", "PGAR_IN_EN"},
-	{"Lineout 2 right switch", "LO2R_SEL_DACR", "Right DAC2"},
-	{"Lineout 2 right switch", "LO2R_SEL_DACR_INV", "Right DAC"},
-
-	{"LO1L_OUT_EN", NULL, "Lineout 1 left switch"},
-	{"LO1R_OUT_EN", NULL, "Lineout 1 right switch"},
-	{"LO2L_OUT_EN", NULL, "Lineout 2 left switch"},
-	{"LO2R_OUT_EN", NULL, "Lineout 2 right switch"},
-
-	{"Lineout 1 left", NULL, "LO1L_OUT_EN"},
-	{"Lineout 1 right", NULL, "LO1R_OUT_EN"},
-	{"Lineout 2 left", NULL, "LO2L_OUT_EN"},
-	{"Lineout 2 right", NULL, "LO2R_OUT_EN"},
-};
-
-static int txlx_acodec_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	struct txlx_acodec_priv *aml_acodec =
-		snd_soc_codec_get_drvdata(dai->codec);
-	uint32_t val;
-
-	pr_info("%s, format:%x\n", __func__, fmt);
-
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		val = 1;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		val = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(aml_acodec->regmap, AUDIO_CONFIG_BLOCK_ENABLE,
-				I2S_MODE, val);
-
-	return 0;
-}
-
-static int txlx_acodec_dai_set_sysclk(struct snd_soc_dai *dai,
-				   int clk_id, unsigned int freq, int dir)
-{
-	return 0;
-}
-
-static int txlx_acodec_dai_hw_params(struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *params,
-			      struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_codec *codec = rtd->codec;
-	struct txlx_acodec_priv *aml_acodec =
-	    snd_soc_codec_get_drvdata(codec);
-
-	pr_info("%s!\n", __func__);
-
-	aml_acodec->params = params;
-
-	return 0;
-}
-
-static int txlx_acodec_dai_set_bias_level(struct snd_soc_codec *codec,
-					 enum snd_soc_bias_level level)
-{
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-
-		break;
-
-	case SND_SOC_BIAS_PREPARE:
-
-		break;
-
-	case SND_SOC_BIAS_STANDBY:
-		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
-			codec->cache_only = false;
-			codec->cache_sync = 1;
-			snd_soc_cache_sync(codec);
-		}
-		break;
-
-	case SND_SOC_BIAS_OFF:
-		snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0);
-		break;
-
-	default:
-		break;
-	}
-	codec->dapm.bias_level = level;
-
-	return 0;
-}
-
-static int txlx_acodec_dai_prepare(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai)
-{
-	/*struct snd_soc_codec *codec = dai->codec;*/
-	txlx_acodec_reg_init(dai->codec);
-
-	pr_debug("%s!\n", __func__);
-
-	return 0;
-
-}
-
-static int txlx_acodec_reset(struct snd_soc_codec *codec)
-{
-	aml_hiu_reset_update_bits(RESET1_REGISTER, (1 << ACODEC_RESET),
-					(1 << ACODEC_RESET));
-	udelay(1000);
-	return 0;
-}
-
-static int txlx_acodec_start_up(struct snd_soc_codec *codec)
-{
-	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xF000);
-	msleep(200);
-	snd_soc_write(codec, AUDIO_CONFIG_BLOCK_ENABLE, 0xB000);
-
-	return 0;
-}
-
-static int txlx_acodec_dai_mute_stream(struct snd_soc_dai *dai, int mute,
-				      int stream)
-{
-	struct txlx_acodec_priv *aml_acodec =
-		snd_soc_codec_get_drvdata(dai->codec);
-	u32 reg;
-
-	pr_debug("%s, mute:%d\n", __func__, mute);
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* DAC 1 */
-		regmap_read(aml_acodec->regmap,
-					DAC_VOL_CTR_DAC_SOFT_MUTE,
-					&reg);
-		if (mute)
-			reg |= DAC_SOFT_MUTE;
-		else
-			reg &= ~DAC_SOFT_MUTE;
-
-		regmap_write(aml_acodec->regmap,
-					DAC_VOL_CTR_DAC_SOFT_MUTE,
-					reg);
-
-
-		/* DAC 2 */
-		regmap_read(aml_acodec->regmap,
-					ACODEC_DAC2_CONFIG2,
-					&reg);
-		if (mute)
-			reg |= DAC2_SOFT_MUTE;
-		else
-			reg &= ~DAC2_SOFT_MUTE;
-
-		regmap_write(aml_acodec->regmap,
-					ACODEC_DAC2_CONFIG2,
-					reg);
-	}
-
-	return 0;
-}
-
-struct snd_soc_dai_ops txlx_acodec_dai_ops = {
-	.hw_params = txlx_acodec_dai_hw_params,
-	.prepare = txlx_acodec_dai_prepare,
-	.set_fmt = txlx_acodec_dai_set_fmt,
-	.set_sysclk = txlx_acodec_dai_set_sysclk,
-	.mute_stream = txlx_acodec_dai_mute_stream,
-};
-
-static int txlx_acodec_probe(struct snd_soc_codec *codec)
-{
-	struct txlx_acodec_priv *aml_acodec =
-		snd_soc_codec_get_drvdata(codec);
-
-	if (!aml_acodec) {
-		pr_err("Failed to get txlx acodec pri\n");
-		return -EINVAL;
-	}
-
-	snd_soc_codec_set_cache_io(codec, 32, 32, SND_SOC_REGMAP);
-
-	/*reset audio codec register*/
-	txlx_acodec_reset(codec);
-	txlx_acodec_start_up(codec);
-	txlx_acodec_reg_init(codec);
-
-	aml_aiu_write(AIU_ACODEC_CTRL, (1 << 4)
-			   |(1 << 6)
-			   |(1 << 11)
-			   |(1 << 15)
-			   |(2 << 2)
-	);
-
-	aml_audin_write(AUDIN_SOURCE_SEL, 3 << 0);
-
-	aml_acodec->codec = codec;
-
-	txlx_acodec_dai_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	return 0;
-}
-
-static int txlx_acodec_remove(struct snd_soc_codec *codec)
-{
-	pr_info("%s!\n", __func__);
-
-	txlx_acodec_dai_set_bias_level(codec, SND_SOC_BIAS_OFF);
-
-	return 0;
-}
-
-static int txlx_acodec_suspend(struct snd_soc_codec *codec)
-{
-	pr_info("%s!\n", __func__);
-
-	txlx_acodec_dai_set_bias_level(codec, SND_SOC_BIAS_OFF);
-
-	return 0;
-}
-
-static int txlx_acodec_resume(struct snd_soc_codec *codec)
-{
-	pr_info("%s!\n", __func__);
-
-	txlx_acodec_reset(codec);
-	txlx_acodec_start_up(codec);
-	txlx_acodec_reg_init(codec);
-
-	txlx_acodec_dai_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	return 0;
-}
-
-static struct snd_soc_codec_driver soc_codec_dev_txlx_acodec = {
-	.probe = txlx_acodec_probe,
-	.remove = txlx_acodec_remove,
-	.suspend = txlx_acodec_suspend,
-	.resume = txlx_acodec_resume,
-	.set_bias_level = txlx_acodec_dai_set_bias_level,
-	.controls = txlx_acodec_snd_controls,
-	.num_controls = ARRAY_SIZE(txlx_acodec_snd_controls),
-	.dapm_widgets = txlx_acodec_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(txlx_acodec_dapm_widgets),
-	.dapm_routes = txlx_acodec_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(txlx_acodec_dapm_routes),
-};
-
-static const struct regmap_config txlx_acodec_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = 0x1c,
-	.reg_defaults = txlx_acodec_init_list,
-	.num_reg_defaults = ARRAY_SIZE(txlx_acodec_init_list),
-	.cache_type = REGCACHE_RBTREE,
-};
-
-#define TXLX_ACODEC_RATES		SNDRV_PCM_RATE_8000_96000
-#define TXLX_ACODEC_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE \
-			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
-			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
-
-struct snd_soc_dai_driver aml_txlx_acodec_dai = {
-	.name = "txlx-acodec-hifi",
-	.id = 0,
-	.playback = {
-	      .stream_name = "Playback",
-	      .channels_min = 2,
-	      .channels_max = 8,
-	      .rates = TXLX_ACODEC_RATES,
-	      .formats = TXLX_ACODEC_FORMATS,
-	      },
-	.capture = {
-	     .stream_name = "Capture",
-	     .channels_min = 2,
-	     .channels_max = 8,
-	     .rates = TXLX_ACODEC_RATES,
-	     .formats = TXLX_ACODEC_FORMATS,
-	     },
-	.ops = &txlx_acodec_dai_ops,
-};
-
-static int aml_txlx_acodec_probe(struct platform_device *pdev)
-{
-	struct txlx_acodec_priv *aml_acodec;
-	struct resource *res_mem;
-	struct device_node *np;
-	void __iomem *regs;
-	int ret = 0;
-
-	dev_info(&pdev->dev, "%s\n", __func__);
-
-	np = pdev->dev.of_node;
-
-	aml_acodec = devm_kzalloc(&pdev->dev, sizeof(struct txlx_acodec_priv),
-				    GFP_KERNEL);
-	if (!aml_acodec)
-		return -ENOMEM;
-
-	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res_mem)
-		return -ENODEV;
-
-	regs = devm_ioremap_resource(&pdev->dev, res_mem);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
-
-	aml_acodec->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-					    &txlx_acodec_regmap_config);
-
-	if (IS_ERR(aml_acodec->regmap))
-		return PTR_ERR(aml_acodec->regmap);
-
-	platform_set_drvdata(pdev, aml_acodec);
-
-	ret = snd_soc_register_codec(&pdev->dev,
-				     &soc_codec_dev_txlx_acodec,
-				     &aml_txlx_acodec_dai, 1);
-
-	return ret;
-}
-
-static int aml_txlx_acodec_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-
-	return 0;
-}
-
-static void aml_txlx_acodec_shutdown(struct platform_device *pdev)
-{
-	struct txlx_acodec_priv *aml_acodec;
-	struct snd_soc_codec *codec;
-
-	aml_acodec = platform_get_drvdata(pdev);
-	codec = aml_acodec->codec;
-	txlx_acodec_remove(codec);
-
-	return;
-}
-
-static const struct of_device_id aml_txlx_acodec_dt_match[] = {
-	{.compatible = "amlogic, txlx_acodec",},
-	{},
-};
-
-static struct platform_driver aml_txlx_acodec_platform_driver = {
-	.driver = {
-		   .name = "aml_codec_txlx_acodec",
-		   .owner = THIS_MODULE,
-		   .of_match_table = aml_txlx_acodec_dt_match,
-		   },
-	.probe = aml_txlx_acodec_probe,
-	.remove = aml_txlx_acodec_remove,
-	.shutdown = aml_txlx_acodec_shutdown,
-};
-
-static int __init aml_txlx_acodec_modinit(void)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&aml_txlx_acodec_platform_driver);
-	if (ret != 0) {
-		pr_err(
-			"Failed to register AML txlx acodec platform driver: %d\n",
-			ret);
-	}
-
-	return ret;
-}
-
-module_init(aml_txlx_acodec_modinit);
-
-static void __exit aml_txlx_acodec_modexit(void)
-{
-	platform_driver_unregister(&aml_txlx_acodec_platform_driver);
-}
-
-module_exit(aml_txlx_acodec_modexit);
-
-MODULE_DESCRIPTION("ASoC AML TXLX audio codec driver");
-MODULE_AUTHOR("AMLogic, Inc.");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/aml_codec_txlx_acodec.h b/sound/soc/codecs/aml_codec_txlx_acodec.h
deleted file mode 100644
index 3709a35..0000000
--- a/sound/soc/codecs/aml_codec_txlx_acodec.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * aml_codec_txlx_acodec.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef _TXLX_ACODEC_H
-#define _TXLX_ACODEC_H
-
-#define DEV_NAME "txlx_acodec"
-
-/* AML TXLX CODEC register space (in decimal to match datasheet) */
-#define ACODEC_BASE_ADD    0xFF632000
-#define ACODEC_TOP_ADDR(x) (x)
-
-#define AUDIO_CONFIG_BLOCK_ENABLE   ACODEC_TOP_ADDR(0x00)
-#define MCLK_FREQ                   31
-#define I2S_MODE                    30
-#define ADC_HPF_EN                  29
-#define ADC_HPF_MODE                28
-#define ADC_OVERLOAD_DET_EN         27
-#define ADC_DEM_EN                  26
-#define ADC_CLK_TO_GPIO_EN          25
-#define DAC_CLK_TO_GPIO_EN          24
-#define DACL_DATA_SOURCE            23
-#define DACR_DATA_SOURCE            22
-#define DACL_INV                    21
-#define DACR_INV                    20
-#define ADCDATL_SOURCE              19
-#define ADCDATR_SOURCE              18
-#define ADCL_INV                    17
-#define ADCR_INV                    16
-#define VMID_GEN_EN                 15
-#define VMID_GEN_FAST               14
-#define BIAS_CURRENT_EN             13
-#define REFP_BUF_EN                 12
-#define PGAL_IN_EN                  11
-#define PGAR_IN_EN                  10
-#define PGAL_IN_ZC_EN               9
-#define PGAR_IN_ZC_EN               8
-#define ADCL_EN                     7
-#define ADCR_EN                     6
-#define DACL_EN                     5
-#define DACR_EN                     4
-#define LO1L_EN                     3
-#define LO1R_EN                     2
-#define LO2L_EN                     1
-#define LO2R_EN                     0
-
-
-#define ADC_VOL_CTR_PGA_IN_CONFIG   ACODEC_TOP_ADDR(0x04)
-#define REG_DAC_GAIN_SEL_1          31
-#define ADCL_VC                     24 /* bit 30-24 */
-#define REG_DAC_GAIN_SEL_0			23
-#define ADCR_VC						16 /* bit 22-16 */
-#define PGAL_IN_SEL					13 /* bit 15-13 */
-#define PGAL_IN_GAIN                8 /* bit 12-8 */
-#define PGAR_IN_SEL                 5 /* bit 7-5 */
-#define PGAR_IN_GAIN                0 /* bit 4-0 */
-
-
-#define DAC_VOL_CTR_DAC_SOFT_MUTE   ACODEC_TOP_ADDR(0x08)
-#define DACL_VC                     24 /* bit 31-24 */
-#define DACR_VC                     16 /* bit 23-16 */
-#define DAC_SOFT_MUTE               15
-#define DAC_UNMUTE_MODE             14
-#define DAC_MUTE_MODE               13
-#define DAC_VC_RAMP_MODE            12
-#define DAC_RAMP_RATE               10 /* bit 11-10 */
-#define DAC_MONO                    8
-#define MUTE_DAC_PD_EN				7
-
-#define LINE_OUT_CONFIG             ACODEC_TOP_ADDR(0x0c)
-#define REG_MICBIAS_EN				31
-#define REG_MICBIAS_SEL				29 /* bit 29, 30 */
-#define REG_ANA_RESERVED			16 /* bit 16 ~ 28 */
-#define LO1L_SEL_DACL				14
-#define LO1L_SEL_AIL				13
-#define LO1L_SEL_AIL_INV			12
-#define LO1R_SEL_DACL_INV			10
-#define LO1R_SEL_DACL				9
-#define LO1R_SEL_AIL				8
-#define LO2L_SEL_DACR				6
-#define LO2L_SEL_AIR				5
-#define LO2L_SEL_AIR_INV			4
-#define LO2R_SEL_DACR_INV			2
-#define LO2R_SEL_DACR				1
-#define LO2R_SEL_AIR				0
-
-
-
-#define POWER_CONFIG                ACODEC_TOP_ADDR(0x10)
-#define MUTE_DAC_WHEN_POWER_DOWN    31
-#define IB_CON                      16 /* bit 16, 17 */
-#define REG_ADCL_SAT_SEL			2 /* bit 2, 3 */
-#define REG_ADCR_SAT_SEL			0 /* bit 0, 1 */
-
-
-#define ACODEC_DAC2_CONFIG          ACODEC_TOP_ADDR(0x14)
-#define DAC2L_VC					24 /* bit 24~31 */
-#define DAC2R_VC					16 /* bit 16~23 */
-#define DAC2L_EN					5
-#define DAC2R_EN					4
-
-#define ACODEC_DAC2_CONFIG2         ACODEC_TOP_ADDR(0x18)
-#define DAC2_SOFT_MUTE				31
-#define DAC2_UNMUTE_MODE			30
-#define DAC2_MUTE_MODE				29
-#define DAC2_VC_RAMP_MODE			28
-#define DAC2_RAMP_RATE				26 /* bit 27-26 */
-#define DAC2_MONO					24
-#define MUTE_DAC2_PD_EN				23
-#define DAC2_CLK_TO_GPIO_EN			8
-#define DAC2L_DATA_SOURCE			7
-#define DAC2R_DATA_SOURCE			6
-#define DAC2L_INV					5
-#define DAC2R_INV					4
-
-
-#define ACODEC_7                    ACODEC_TOP_ADDR(0x1C)
-#define DEBUG_BUS_SEL				16 /* bit 16~18 */
-#define REG_DAC2_GAIN_SEL_1			15
-#define AU_VMID_FAST_SEL			8 /* bit 8~11 */
-#define REG_DAC2_GAIN_SEL_0			7
-#define AU_VMID_SEL					0 /* bit 0~3 */
-
-#endif /*_TXLX_ACODEC_H*/
-- 
2.7.4

From 0065e6e3347296fc3c9a705f3fdaedd8b2eaa21f Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 19:06:39 +0800
Subject: [PATCH] audio-remote t9015 codec

---
 sound/soc/codecs/Kconfig  | 6 ------
 sound/soc/codecs/Makefile | 4 ----
 2 files changed, 10 deletions(-)

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 69b0a56..27453e2 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -584,9 +584,3 @@ config SND_SOC_ES8323
 
 config SND_SOC_PCM2BT
 	tristate
-
-config SND_SOC_AMLT9015
-	tristate
-
-config SND_SOC_AMLT9015S
-	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 711ef11..1a8a8b5 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -127,8 +127,6 @@ snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-dummy_codec-objs := dummy_codec.o
 snd-soc-pcm2bt-objs  := pcm2bt.o
 snd-soc-amlpmu4-objs := aml_pmu4_codec.o
-snd-soc-aml_t9015-objs := aml_codec_t9015.o
-snd-soc-aml_t9015S-objs := aml_codec_t9015S.o
 snd-soc-es8323-objs := es8323.o
 
 # Amp
@@ -266,8 +264,6 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_DUMMY_CODEC)	+= snd-soc-dummy_codec.o
 obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
 obj-$(CONFIG_SND_SOC_AMLPMU4)	+= snd-soc-amlpmu4.o
-obj-$(CONFIG_SND_SOC_AMLT9015)	+= snd-soc-aml_t9015.o
-obj-$(CONFIG_SND_SOC_AMLT9015S)	+= snd-soc-aml_t9015S.o
 obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
 
 # Amp
-- 
2.7.4

From 0e35cd11c6400fc0a61918aaeb301e00b8a38e63 Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 19:47:34 +0800
Subject: [PATCH] audio: revert PD#127392: hdmirx: add sw_mute before timing
 switch

---
 drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c | 30 +++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
index eb90e51..566bcc9 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
+++ b/drivers/amlogic/tvin/hdmirx/hdmi_rx_wrapper.c
@@ -509,6 +509,7 @@ static int last_color_fmt;
 static bool reset_sw = true;
 static int sm_pause;
 static bool edid_addr_intr_flag;
+static bool use_audioresample_reset;
 static int fsm_enhancement;
 static int port_select_ovr_en;
 static int phy_cmu_config_force_val;
@@ -2227,11 +2228,36 @@ void rx_aud_pll_ctl(bool en)
 		wr_reg_hhi(HHI_ADC_PLL_CNTL4, 0x805);
 		tmp = hdmirx_rd_top(TOP_ACR_CNTL_STAT) | (1<<11);
 		hdmirx_wr_top(TOP_ACR_CNTL_STAT, tmp);
-		External_Mute(0);
+		#if 0
+		if (use_audioresample_reset) {
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0)
+					| (1 << 31));
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0) &
+					0x7fffffff);
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0)
+				| (1 << 29)
+				| (1 << 28));
+		}
+		#endif
 	} else{
 		/* disable pll, into reset mode */
-		External_Mute(1);
 		wr_reg_hhi(HHI_AUD_PLL_CNTL, 0x20000000);
+		if (use_audioresample_reset) {
+			/* reset resample module */
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0)
+					| (1 << 31));
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0) &
+					0x7fffffff);
+			aml_write_cbus(AUD_RESAMPLE_CTRL0,
+				aml_read_cbus(AUD_RESAMPLE_CTRL0)
+				| (1 << 29)
+				| (1 << 28));
+		}
 	}
 }
 
-- 
2.7.4

From 6acb16a9f4b09ffa370677bc0a2096c73d8e11f3 Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 19:42:19 +0800
Subject: [PATCH] revert-hdmirx_drv.h

---
 drivers/amlogic/tvin/hdmirx/hdmirx_drv.h | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
index 2183325..1000e42 100644
--- a/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
+++ b/drivers/amlogic/tvin/hdmirx/hdmirx_drv.h
@@ -891,13 +891,9 @@ extern void hdmi_rx_ctrl_hdcp_config(const struct hdmi_rx_ctrl_hdcp *hdcp);
  * tvafe:0x4; dac:0x8, audio pll:0x10
 */
 
+extern void vdac_enable(bool on, unsigned int module_sel);
 extern void hdmirx_phy_bist_test(int lvl);
 extern int hdmirx_dev_init(void);
 extern void dump_eq_data(void);
 extern void repeater_dwork_handle(struct work_struct *work);
-/* for other modules */
-extern int External_Mute(int mute_flag);
-extern void vdac_enable(bool on, unsigned int module_sel);
-extern void hdmirx_dv_packet_stop(void);
-
 #endif  /* _TVHDMI_H */
-- 
2.7.4

From 799eda9bea07ecf8e05a43947aaa23febab02529 Mon Sep 17 00:00:00 2001
From: wrxtasy <wrxtasy@amnet.net.au>
Date: Fri, 16 Mar 2018 16:01:56 +0800
Subject: [PATCH] revert drivers/amlogic/cec/hdmi_ao_cec.c

---
 drivers/amlogic/cec/hdmi_ao_cec.c | 449 +++-----------------------------------
 1 file changed, 28 insertions(+), 421 deletions(-)

diff --git a/drivers/amlogic/cec/hdmi_ao_cec.c b/drivers/amlogic/cec/hdmi_ao_cec.c
index 9682f7c..9de72d7 100644
--- a/drivers/amlogic/cec/hdmi_ao_cec.c
+++ b/drivers/amlogic/cec/hdmi_ao_cec.c
@@ -67,7 +67,7 @@ static struct early_suspend aocec_suspend_handler;
 #include <linux/amlogic/jtag.h>
 
 #define CEC_FRAME_DELAY		msecs_to_jiffies(400)
-#define CEC_DEV_NAME		"aocec"
+#define CEC_DEV_NAME		"cec"
 
 #define DEV_TYPE_TV			0
 #define DEV_TYPE_RECORDER		1
@@ -147,14 +147,14 @@ static bool ee_cec;
 static bool pin_status;
 bool cec_msg_dbg_en = 0;
 
-#define CEC_ERR(format, args...)                \
-	{if (cec_dev->dbg_dev)                  \
-		dev_err(cec_dev->dbg_dev, "%s(): " format, __func__, ##args);  \
+#define CEC_ERR(format, args...)				\
+	{if (cec_dev->dbg_dev)					\
+		dev_err(cec_dev->dbg_dev, format, ##args);	\
 	}
 
-#define CEC_INFO(format, args...)               \
-	{if (cec_msg_dbg_en && cec_dev->dbg_dev)        \
-		dev_info(cec_dev->dbg_dev, "%s(): " format, __func__, ##args); \
+#define CEC_INFO(format, args...)				\
+	{if (cec_msg_dbg_en && cec_dev->dbg_dev)		\
+		dev_info(cec_dev->dbg_dev, format, ##args);	\
 	}
 
 static unsigned char msg_log_buf[128] = { 0 };
@@ -170,75 +170,6 @@ static unsigned char msg_log_buf[128] = { 0 };
 		} \
 	} while (0)
 
-#define HR_DELAY(n)     (ktime_set(0, n * 1000 * 1000))
-__u16 cec_key_map[160] = {
-	KEY_ENTER, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
-	0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
-	0 , 0, 0, 0, 0, 0, 0, 0,//0x10
-	0 , 0, 0, 0, 0, 0, 0, 0,
-	KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
-	KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
-	KEY_CHANNELUP , KEY_CHANNELDOWN, KEY_CHANNEL, 0, 0, 0, 0, 0,//0x30
-	0 , 0, 0, 0, 0, 0, 0, 0,
-
-	KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
-	KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
-	0 , 0, 0, KEY_PROGRAM, 0, 0, 0, 0,//0x50
-	0 , 0, 0, 0, 0, 0, 0, 0,
-	KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
-	0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
-	0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
-	0 , 0, 0, 0, 0, 0, 0, 0x2fd,
-	0 , 0, 0, 0, 0, 0, 0, 0,//0x80
-	0 , 0, 0, 0, 0, 0, 0, 0,
-	0 , KEY_EXIT, 0, 0, 0, 0, KEY_PVR, 0,//0x90  //samsung vendor buttons return and channel_list
-	0 , 0, 0, 0, 0, 0, 0, 0,
-};
-
-struct hrtimer cec_key_timer;
-static int last_key_irq = -1;
-static int key_value = 1;
-enum hrtimer_restart cec_key_up(struct hrtimer *timer)
-{
-	if (key_value == 1){
-		input_event(cec_dev->cec_info.remote_cec_dev,
-		EV_KEY, cec_key_map[last_key_irq], 0);
-	}
-	input_sync(cec_dev->cec_info.remote_cec_dev);
-	CEC_INFO("last:%d up\n", cec_key_map[last_key_irq]);
-	key_value = 2;
-
-	return HRTIMER_NORESTART;
-}
-
-void cec_user_control_pressed_irq(unsigned char message_irq)
-{
-	if (message_irq < 160) {
-		CEC_INFO("Key pressed: %d\n", message_irq);
-		input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY,
-				cec_key_map[message_irq], key_value);
-		input_sync(cec_dev->cec_info.remote_cec_dev);
-		last_key_irq = message_irq;
-		hrtimer_start(&cec_key_timer, HR_DELAY(200), HRTIMER_MODE_REL);
-		CEC_INFO(":key map:%d\n", cec_key_map[message_irq]);
-	}
-}
-
-void cec_user_control_released_irq(void)
-{
-	/*
-	 * key must be valid
-	 */
-	if (last_key_irq != -1) {
-		CEC_INFO("Key released: %d\n",last_key_irq);
-		hrtimer_cancel(&cec_key_timer);
-		input_event(cec_dev->cec_info.remote_cec_dev,
-				EV_KEY, cec_key_map[last_key_irq], 0);
-		input_sync(cec_dev->cec_info.remote_cec_dev);
-		key_value = 1;
-	}
-}
-
 static void cec_set_reg_bits(unsigned int addr, unsigned int value,
 	unsigned int offset, unsigned int len)
 {
@@ -255,12 +186,12 @@ unsigned int aocec_rd_reg(unsigned long addr)
 	unsigned int data32;
 	unsigned long flags;
 
-	spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
 	waiting_aocec_free(AO_CEC_RW_REG);
+	spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
 	data32 = 0;
 	data32 |= 0 << 16; /* [16]	 cec_reg_wr */
 	data32 |= 0 << 8; /* [15:8]   cec_reg_wrdata */
-	data32 |= (addr & 0xff) << 0; /* [7:0]	cec_reg_addr */
+	data32 |= addr << 0; /* [7:0]	cec_reg_addr */
 	writel(data32, cec_dev->cec_reg + AO_CEC_RW_REG);
 
 	waiting_aocec_free(AO_CEC_RW_REG);
@@ -271,17 +202,16 @@ unsigned int aocec_rd_reg(unsigned long addr)
 
 void aocec_wr_reg(unsigned long addr, unsigned long data)
 {
-	unsigned int data32;
+	unsigned long data32;
 	unsigned long flags;
 
-	spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
 	waiting_aocec_free(AO_CEC_RW_REG);
+	spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
 	data32 = 0;
 	data32 |= 1 << 16; /* [16]	 cec_reg_wr */
-	data32 |= (data & 0xff) << 8; /* [15:8]   cec_reg_wrdata */
-	data32 |= (addr & 0xff) << 0; /* [7:0]	cec_reg_addr */
+	data32 |= data << 8; /* [15:8]   cec_reg_wrdata */
+	data32 |= addr << 0; /* [7:0]	cec_reg_addr */
 	writel(data32, cec_dev->cec_reg + AO_CEC_RW_REG);
-	waiting_aocec_free(AO_CEC_RW_REG);
 	spin_unlock_irqrestore(&cec_dev->cec_reg_lock, flags);
 } /* aocec_wr_only_reg */
 
@@ -878,41 +808,6 @@ int cec_ll_rx(unsigned char *msg, unsigned char *len)
 	return ret;
 }
 
-void cec_polling_online_dev(int log_addr, int *bool)
-{
-	unsigned int r;
-	unsigned char msg[1];
-	int retry = 5;
-
-	msg[0] = (log_addr<<4) | log_addr;
-	/* set broadcast address first */
-	cec_logicaddr_set(0xf);
-	if (cec_msg_dbg_en == 1)
-		CEC_INFO("CEC_LOGICAL_ADDR0:0x%i\n",
-				 aocec_rd_reg(CEC_LOGICAL_ADDR0));
-	while (retry) {
-		r = cec_ll_tx(msg, 1);
-		if (r == CEC_FAIL_BUSY) {
-			retry--;
-			CEC_INFO("try log addr %x busy, retry:%d\n",
-					 log_addr, retry);
-			/*
-			 * try to reset CEC if tx busy is found
-			 */
-			cec_hw_reset();
-		} else
-			break;
-	}
-
-	if (r == CEC_FAIL_NACK) {
-		*bool = 0;
-	} else if (r == CEC_FAIL_NONE) {
-		*bool = 1;
-	}
-	CEC_INFO("CEC: poll online logic device: 0x%x BOOL: %d\n",
-			 log_addr, *bool);
-}
-
 /************************ cec arbitration cts code **************************/
 /* using the cec pin as fiq gpi to assist the bus arbitration */
 
@@ -1326,18 +1221,6 @@ unsigned int cec_phyaddr_config(unsigned int value, bool wr_flag)
 	return readl(cec_dev->cec_reg + AO_DEBUG_REG1);
 }
 
-/*
- *wr_flag:1 write; value valid
- *      0 read;  value invalid
- */
-unsigned int cec_logicaddr_config(unsigned int value, bool wr_flag)
-{
-	if (wr_flag)
-		cec_set_reg_bits(AO_DEBUG_REG3, value, 0, 8);
-
-	return readl(cec_dev->cec_reg + AO_DEBUG_REG3);
-}
-
 void cec_keep_reset(void)
 {
 	if (ee_cec)
@@ -1363,8 +1246,6 @@ static void cec_pre_init(void)
 	}
 	ao_cec_init();
 
-	cec_config(cec_dev->tx_dev->cec_func_config, 1);
-
 	cec_arbit_bit_time_set(3, 0x118, 0);
 	cec_arbit_bit_time_set(5, 0x000, 0);
 	cec_arbit_bit_time_set(7, 0x2aa, 0);
@@ -1474,27 +1355,6 @@ void cec_menu_status_smp(int dest, int status)
 	cec_ll_tx(msg, 3);
 }
 
-void cec_imageview_on_smp(void)
-{
-	unsigned char msg[2];
-	unsigned char index = cec_dev->cec_info.log_addr;
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_IMAGE_VIEW_ON;
-	cec_ll_tx(msg, 2);
-}
-
-void cec_get_menu_language_smp(void)
-{
-	unsigned char msg[2];
-	unsigned char index = cec_dev->cec_info.log_addr;
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_GET_MENU_LANGUAGE;
-
-	cec_ll_tx(msg, 2);
-}
-
 void cec_inactive_source(int dest)
 {
 	unsigned char index = cec_dev->cec_info.log_addr;
@@ -1579,149 +1439,6 @@ void cec_report_power_status(int dest, int status)
 	cec_ll_tx(msg, 3);
 }
 
-void cec_send_simplink_alive(void)
-{
-	unsigned char index = cec_dev->cec_info.log_addr;
-	unsigned char msg[4];
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_VENDOR_COMMAND;
-	msg[2] = 0x2;
-	msg[3] = 0x5;
-
-	cec_ll_tx(msg, 4);
-}
-
-void cec_send_simplink_ack(void)
-{
-	unsigned char index = cec_dev->cec_info.log_addr;
-	unsigned char msg[4];
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_VENDOR_COMMAND;
-	msg[2] = 0x5;
-	msg[3] = 0x1;
-
-	cec_ll_tx(msg, 4);
-}
-
-int cec_node_init(struct hdmitx_dev *hdmitx_device)
-{
-	unsigned char a, b, c, d;
-
-	int i, bool = 0;
-	int phy_addr_ok = 1;
-	const enum _cec_log_dev_addr_e player_dev[3] = {
-		CEC_RECORDING_DEVICE_1_ADDR,
-		CEC_RECORDING_DEVICE_2_ADDR,
-		CEC_RECORDING_DEVICE_3_ADDR,
-	};
-
-	unsigned long cec_phy_addr;
-
-	/* If no connect, return directly */
-	if ((hdmitx_device->cec_init_ready == 0) ||
-			(hdmitx_device->hpd_state == 0)) {
-		return -1;
-	}
-
-	if (wait_event_interruptible(hdmitx_device->hdmi_info.vsdb_phy_addr.waitq,
-		hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 1))
-	{
-		CEC_INFO("error during wait for a valid physical address\n");
-		return -ERESTARTSYS;
-	}
-
-	a = hdmitx_device->hdmi_info.vsdb_phy_addr.a;
-	b = hdmitx_device->hdmi_info.vsdb_phy_addr.b;
-	c = hdmitx_device->hdmi_info.vsdb_phy_addr.c;
-	d = hdmitx_device->hdmi_info.vsdb_phy_addr.d;
-
-	/* Don't init if switched to libcec mode*/
-	if ((cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))
-		return -1;
-
-	if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
-		return -1;
-
-	CEC_INFO("cec_node_init started\n");
-
-	cec_phy_addr = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
-
-	for (i = 0; i < 3; i++) {
-		CEC_INFO("CEC: start poll dev\n");
-		cec_polling_online_dev(player_dev[i], &bool);
-		CEC_INFO("player_dev[%d]:0x%x\n", i, player_dev[i]);
-		if (bool == 0) {   /* 0 means that no any respond */
-			/* If VSDB is not valid, use last or default physical address. */
-			cec_logicaddr_set(player_dev[i]);
-			if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
-				phy_addr_ok = 0;
-				CEC_INFO("invalid cec PhyAddr\n");
-				if (cec_phyaddr_config(0, 0)) {
-					CEC_INFO("use last physical address\n");
-				} else {
-					cec_phyaddr_config(0x2000, 1);
-					CEC_INFO("use Def Phy address\n");
-				}
-			} else
-				cec_phyaddr_config(cec_phy_addr, 1);
-
-			CEC_INFO("physical address:0x%x\n",
-					 cec_phyaddr_config(0, 0));
-
-			cec_dev->cec_info.power_status = TRANS_STANDBY_TO_ON;
-			cec_logicaddr_config(player_dev[i], 1);
-			cec_dev->cec_info.log_addr = player_dev[i];
-			/* Set Physical address */
-			cec_dev->phy_addr = cec_phy_addr;
-
-			cec_dev->cec_info.cec_version = CEC_VERSION_14A;
-			cec_dev->cec_info.vendor_id = cec_dev->v_data.vendor_id;
-			strcpy(cec_dev->cec_info.osd_name,
-				   cec_dev->v_data.cec_osd_string);
-			cec_logicaddr_set(player_dev[i]);
-
-			CEC_INFO("Set logical address: %d\n",
-					 player_dev[i]);
-
-			cec_dev->cec_info.power_status = POWER_ON;
-			if (cec_dev->cec_info.menu_status == DEVICE_MENU_INACTIVE)
-				break;
-			msleep(100);
-			if (phy_addr_ok) {
-				cec_report_physical_address_smp();
-				msleep(150);
-			}
-			cec_device_vendor_id();
-			cec_set_osd_name(0);
-
-			/* Disable switch TV on automatically */
-			if (!(hdmitx_device->cec_func_config &
-					(1 << AUTO_POWER_ON_MASK))) {
-				CEC_INFO("Auto TV switch on disabled\n");
-				break;
-			}
-
-			cec_active_source_smp();
-			cec_imageview_on_smp();
-
-			cec_menu_status_smp(CEC_TV_ADDR, DEVICE_MENU_ACTIVE);
-
-			msleep(100);
-			cec_get_menu_language_smp();
-			cec_dev->cec_info.menu_status = DEVICE_MENU_ACTIVE;
-			break;
-		}
-	}
-	if (bool == 1) {
-		CEC_INFO("Can't get a valid logical address\n");
-		return -1;
-	} else {
-		CEC_INFO("cec node init: cec features ok !\n");
-		return 0;
-	}
-}
 static void cec_rx_process(void)
 {
 	int len = rx_len;
@@ -1743,15 +1460,15 @@ static void cec_rx_process(void)
 	opcode = msg[1];
 	switch (opcode) {
 	case CEC_OC_ACTIVE_SOURCE:
-		//if (wake_ok == 0) {
-		//	int phy_addr = msg[2] << 8 | msg[3];
-		//	if (phy_addr == 0xffff)
-		//		break;
-		//	wake_ok = 1;
-		//	phy_addr |= (initiator << 16);
-		//	writel(phy_addr, cec_dev->cec_reg + AO_RTI_STATUS_REG1);
-		//	CEC_INFO("found wake up source:%x", phy_addr);
-		//}
+		if (wake_ok == 0) {
+			int phy_addr = msg[2] << 8 | msg[3];
+			if (phy_addr == 0xffff)
+				break;
+			wake_ok = 1;
+			phy_addr |= (initiator << 16);
+			writel(phy_addr, cec_dev->cec_reg + AO_RTI_STATUS_REG1);
+			CEC_INFO("found wake up source:%x", phy_addr);
+		}
 		break;
 
 	case CEC_OC_ROUTING_CHANGE:
@@ -1806,15 +1523,7 @@ static void cec_rx_process(void)
 			cec_report_power_status(initiator, POWER_ON);
 		break;
 
-
-	case CEC_OC_USER_CONTROL_RELEASED:
-		cec_user_control_released_irq();
-		break;
-
 	case CEC_OC_USER_CONTROL_PRESSED:
-		if (len < 3)
-			break;
-		cec_user_control_pressed_irq(msg[2]);
 		/* wake up by key function */
 		if (cec_dev->cec_suspend == CEC_EARLY_SUSPEND) {
 			if (msg[2] == 0x40 || msg[2] == 0x6d)
@@ -1822,87 +1531,12 @@ static void cec_rx_process(void)
 		}
 		break;
 
-	case CEC_OC_PLAY:
-		if (len < 3)
-			break;
-		switch (msg[2]) {
-		case 0x24:
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_PLAYPAUSE, 1);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_PLAYPAUSE, 0);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			break;
-		case 0x25:
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_PLAYPAUSE, 1);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_PLAYPAUSE, 0);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			break;
-		default:
-			break;
-		}
-		break;
-
-	case CEC_OC_DECK_CONTROL:
-		if (len < 3)
-			break;
-		switch (msg[2]) {
-		case 0x3:
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_STOP, 1);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			input_event(cec_dev->cec_info.remote_cec_dev,
-						EV_KEY, KEY_STOP, 0);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			break;
-		default:
-			break;
-		}
-		break;
-
-	case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-		if (len < 3)
-			break;
-		switch(msg[2]) {
-		//samsung vendor keys
-		case 0x91:
-			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 1);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 0);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			break;
-		case 0x96:
-			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 1);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 0);
-			input_sync(cec_dev->cec_info.remote_cec_dev);
-			break;
-		default:
-			break;
-		}
-		break;
 	case CEC_OC_MENU_REQUEST:
 		if (cec_dev->cec_suspend)
 			cec_menu_status_smp(initiator, DEVICE_MENU_INACTIVE);
 		else
 			cec_menu_status_smp(initiator, DEVICE_MENU_ACTIVE);
 		break;
-	case CEC_OC_VENDOR_COMMAND:
-		if (len < 3)
-			break;
-		if (msg[2] == 0x1) {
-			cec_report_power_status(initiator, cec_dev->cec_info.power_status);
-			cec_send_simplink_alive();
-		} else if (msg[2] == 0x4) {
-			cec_send_simplink_ack();
-		}
-		break;
-	case CEC_OC_DEVICE_VENDOR_ID:
-		break;
 
 	default:
 		CEC_ERR("unsupported command:%x\n", opcode);
@@ -1924,18 +1558,10 @@ static bool cec_service_suspended(void)
 static void cec_task(struct work_struct *work)
 {
 	struct delayed_work *dwork;
-	int ret;
 
 	dwork = &cec_dev->cec_work;
-	if (cec_dev && cec_service_suspended()) {
-		if (1 << cec_dev->cec_info.log_addr & (1 << 0x0 | 1 << 0xF)) {
-			ret = cec_node_init(cec_dev->tx_dev);
-			if (ret < 0) {
-				return;
-			}
-		}
+	if (cec_dev && (!wake_ok || cec_service_suspended()))
 		cec_rx_process();
-	}
 
 	if (!cec_late_check_rx_buffer())
 		queue_delayed_work(cec_dev->cec_thread, dwork, CEC_FRAME_DELAY);
@@ -2284,16 +1910,11 @@ static struct class_attribute aocec_class_attr[] = {
 /******************** cec hal interface ***************************/
 static int hdmitx_cec_open(struct inode *inode, struct file *file)
 {
-	if (wait_event_interruptible(cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.waitq,
-		cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.valid == 1))
-	{
-		CEC_INFO("error during wait for a valid physical address\n");
-		return -ERESTARTSYS;
-	}
-
 	cec_dev->cec_info.open_count++;
 	if (cec_dev->cec_info.open_count) {
 		cec_dev->cec_info.hal_ctl = 1;
+		/* set default logical addr flag for uboot */
+		cec_set_reg_bits(AO_DEBUG_REG1, 0xf, 16, 4);
 	}
 	return 0;
 }
@@ -2321,7 +1942,6 @@ static ssize_t hdmitx_cec_read(struct file *f, char __user *buf,
 
 	if (copy_to_user(buf, rx_msg, rx_len))
 		return -EINVAL;
-	CEC_INFO("RX len: %d\n", rx_len);
 	return rx_len;
 }
 
@@ -2340,14 +1960,7 @@ static ssize_t hdmitx_cec_write(struct file *f, const char __user *buf,
 		return -EINVAL;
 
 	ret = cec_ll_tx(tempbuf, size);
-	/* delay a byte for continue message send */
-	msleep(25);
-	if (ret == CEC_FAIL_NACK) {
-		return -1;
-	}
-	else {
-		return size;
-	}
+	return ret;
 }
 
 static void init_cec_port_info(struct hdmi_port_info *port,
@@ -2588,7 +2201,6 @@ static long hdmitx_cec_ioctl(struct file *f,
 
 	case CEC_IOC_ADD_LOGICAL_ADDR:
 		tmp = arg & 0xf;
-		CEC_INFO("CEC LA ARG:%ld", arg);
 		cec_logicaddr_set(tmp);
 		/* add by hal, to init some data structure */
 		cec_dev->cec_info.log_addr = tmp;
@@ -2685,7 +2297,6 @@ static void aocec_late_resume(struct early_suspend *h)
 
 static int aml_cec_probe(struct platform_device *pdev)
 {
-	int i;
 	struct device *cdev;
 #ifdef CONFIG_OF
 	struct device_node *node = pdev->dev.of_node;
@@ -2741,8 +2352,6 @@ static int aml_cec_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 	INIT_DELAYED_WORK(&cec_dev->cec_work, cec_task);
-	hrtimer_init(&cec_key_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	cec_key_timer.function = cec_key_up;
 	cec_dev->cec_info.remote_cec_dev = input_allocate_device();
 	if (!cec_dev->cec_info.remote_cec_dev)
 		CEC_INFO("No enough memory\n");
@@ -2757,8 +2366,8 @@ static int aml_cec_probe(struct platform_device *pdev)
 	cec_dev->cec_info.remote_cec_dev->id.product = 0x0cec;
 	cec_dev->cec_info.remote_cec_dev->id.version = 0x0001;
 
-	for (i = 0; i < 160; i++)
-		set_bit(cec_key_map[i], cec_dev->cec_info.remote_cec_dev->keybit);
+	set_bit(KEY_POWER, cec_dev->cec_info.remote_cec_dev->keybit);
+
 	if (input_register_device(cec_dev->cec_info.remote_cec_dev)) {
 		CEC_INFO("Failed to register device\n");
 		input_free_device(cec_dev->cec_info.remote_cec_dev);
@@ -2893,7 +2502,6 @@ static int aml_cec_probe(struct platform_device *pdev)
 	/* for init */
 	cec_pre_init();
 	queue_delayed_work(cec_dev->cec_thread, &cec_dev->cec_work, 0);
-	cec_dev->tx_dev->cec_init_ready = 1;
 	return 0;
 }
 
@@ -2902,7 +2510,6 @@ static int aml_cec_remove(struct platform_device *pdev)
 	CEC_INFO("cec uninit!\n");
 	free_irq(cec_dev->irq_cec, (void *)cec_dev);
 	kfree(last_cec_msg);
-	cec_dev->tx_dev->cec_init_ready = 0;
 
 	if (cec_dev->cec_thread) {
 		cancel_delayed_work_sync(&cec_dev->cec_work);
-- 
2.7.4

